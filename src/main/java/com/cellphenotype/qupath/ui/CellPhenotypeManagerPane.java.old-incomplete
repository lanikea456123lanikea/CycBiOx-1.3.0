//TODO: [代码功能] 主界面 (5200+行) ⭐ 核心文件
// VERSION: v1.1.0 (2024.09.24) - 稳定性修复版本
// STATUS: ✅ 7个关键Bug修复完成，功能稳定
// FIXES: 细胞显示形状|导出按钮|配置加载|策略切换|LOAD模式|API接口|预览缩放

package com.cellphenotype.qupath.ui;

// TODO: [导入] 依赖库导入
import com.cellphenotype.qupath.CellPhenotypeAPI;
import com.cellphenotype.qupath.classifier.CellPhenotypeClassifier;
import com.cellphenotype.qupath.model.CellPhenotype;
import com.cellphenotype.qupath.model.PhenotypeManager;
import com.cellphenotype.qupath.model.ThresholdConfig;
import com.fasterxml.jackson.databind.ObjectMapper;
import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.concurrent.Task;
import javafx.geometry.Insets;
import javafx.geometry.Orientation;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.layout.*;
import javafx.stage.Modality;
import javafx.stage.DirectoryChooser;
import javafx.stage.Stage;
import javafx.util.StringConverter;
import qupath.lib.gui.QuPathGUI;
import qupath.lib.gui.viewer.OverlayOptions;
import qupath.lib.images.ImageData;
import qupath.lib.images.servers.ImageChannel;
import qupath.lib.objects.classes.PathClass;
import qupath.lib.projects.Project;
import qupath.lib.projects.ProjectImageEntry;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.IOException;
import java.util.*;
import java.util.stream.Collectors;

// TODO: [类] CycBiOx主界面控制器 - 细胞表型分类管理
// FIXME: [性能] 优化大数据集处理性能
// NOTE: [架构] 支持CREATE预览和LOAD执行双模式

public class CellPhenotypeManagerPane {
    
    // TODO: [常量] 日志记录器
    private static final Logger logger = LoggerFactory.getLogger(CellPhenotypeManagerPane.class);

    // TODO: [常量] 测量类型列表 - QuPath支持的12种细胞测量
    private static final List<String> MEASUREMENT_TYPES = Arrays.asList(
        "Nucleus: Mean", "Nucleus: Median", "Nucleus: Max", "Nucleus: Min",
        "Cell: Mean", "Cell: Median", "Cell: Max", "Cell: Min",
        "Cytoplasm: Mean", "Cytoplasm: Median", "Cytoplasm: Max", "Cytoplasm: Min"
    );

    // TODO: [枚举] 操作模式
    // TODO: [CREATE模式] 单通道预览模式，实时调试
    // TODO: [LOAD模式] 多通道执行模式，正式分类
    private enum OperationMode {
        CREATE_CLASSIFIER("确定通道阳性阈值"),
        LOAD_CLASSIFIER("选择所需通道，执行策略");

        private final String displayName;

        OperationMode(String displayName) {
            this.displayName = displayName;
        }

        @Override
        public String toString() {
            return displayName;
        }
    }

    // TODO: [字段] 核心状态变量
    private OperationMode currentMode = OperationMode.CREATE_CLASSIFIER;
    private ComboBox<OperationMode> modeComboBox;
    // TODO: [字段] 阈值控制状态
    private ComboBox<String> algorithmComboBox;
    private Button calculateButton;
    // TODO: [字段] 预览功能状态
    private boolean livePreviewEnabled = false;
    private String currentPreviewChannel = null;
    private List<String> selectedChannelsFromThreshold = new ArrayList<>();
    // TODO: [字段] 操作按钮控件
    private Button executeButton;                                         // 执行按钮
    private Button refreshButton;                                         // 刷新按钮

    // TODO: [字段] 阈值数据管理
    private Map<String, Double> savedAutoThresholds = new HashMap<>();
    private boolean isAutoMode = false;

    // TODO: [字段] CREATE模式选择状态保存
    private Map<String, Boolean> createModeSelections = new HashMap<>();

    // TODO: [字段] 通道数据管理
    private List<String> availableChannels = new ArrayList<>();
    // TODO: [数据] 通道名称映射
    private Map<String, String> channelNameMapping = new HashMap<>();

    // TODO: [数据] 分类结果映射
    private Map<String, String> classificationMapping = new HashMap<>();

    // TODO: [UI组件] 基础设置
    private TextField savePathField;
    private CheckBox roiToggle;
    private ComboBox<String> cellAnalysisComboBox;

    // TODO: [UI组件] QuPath集成
    private final QuPathGUI qupath;
    private Stage stage;

    // TODO: [UI组件] 配置管理
    private TextField configNameField;
    private ComboBox<ThresholdConfig.Strategy> strategyComboBox;

    // TODO: [UI组件] 阈值控制组件映射
    private final Map<String, RadioButton> channelRadioButtons = new HashMap<>();
    private final Map<String, CheckBox> channelCheckBoxes = new HashMap<>();
    private final Map<String, ComboBox<String>> measurementComboBoxes = new HashMap<>();
    private final Map<String, Slider> thresholdSliders = new HashMap<>();
    private final Map<String, TextField> thresholdFields = new HashMap<>();
    private final Map<String, Label> thresholdStatusLabels = new HashMap<>();

    // TODO: [UI组件] 通道控件管理
    private ToggleGroup channelToggleGroup;
    private ToggleGroup singleChannelGroup;
    private VBox channelContainer;

    // TODO: [UI组件] 表型管理表格
    private TableView<PhenotypeTableRow> phenotypeTable;
    private ObservableList<PhenotypeTableRow> phenotypeData;

    // TODO: [配置] 当前配置状态
    private ThresholdConfig currentConfig;
    private List<CellPhenotype> phenotypes;

    // TODO: [功能] ROI支持
    private boolean useSelectedROI = false;
    private CheckBox roiModeCheckBox;

    // TODO: [方法] 待优化方法

    public CellPhenotypeManagerPane(QuPathGUI qupath) {
        this.qupath = qupath;
        this.phenotypes = new ArrayList<>();
        this.currentConfig = new ThresholdConfig("配置表1");
        this.channelToggleGroup = new ToggleGroup();
        loadAvailableChannels();
        initializeThresholds();
    }

    // TODO: [方法] 加载可用通道列表
    private void loadAvailableChannels() {
        ImageData<?> imageData = qupath.getImageData();
        if (imageData != null) {
            List<ImageChannel> channels = imageData.getServer().getMetadata().getChannels();
            availableChannels.clear();
            channelNameMapping.clear(); // TODO: [数据] 清除之前的映射
            
            logger.info("=== 开始分析图像通道信息 ===");
            logger.info("图像总通道数: {}", channels.size());
            
            // TODO: [调试] 检查measurement名称
            debugAvailableMeasurements(imageData);
            
            int analysisChannelIndex = 0; // TODO: [计数] 分析通道索引
            
            for (int i = 0; i < channels.size(); i++) {
                ImageChannel channel = channels.get(i);
                String originalName = channel.getName();
                String displayName = originalName;
                
                // TODO: [验证] 处理空通道名称
                if (displayName == null || displayName.trim().isEmpty()) {
                    displayName = "Channel " + (i + 1);
                }
                
                logger.info("通道 {} - 原始名称: '{}', 显示名称: '{}'", i, originalName, displayName);
                
                // TODO: [过滤] 跳过DAPI通道
                boolean isDAPI = displayName.toLowerCase().contains("dapi") || 
                               displayName.toLowerCase().contains("hoechst") ||
                               displayName.toLowerCase().contains("nucleus");
                               
                if (isDAPI) {
                    logger.info("跳过核染色通道: '{}'", displayName);
                    continue;
                }
                
                // TODO: [处理] 分析通道处理
                analysisChannelIndex++;
                String finalDisplayName = displayName;
                availableChannels.add(finalDisplayName);
                
                // TODO: [映射] QuPath映射策略
                String originalNameForMapping = originalName != null ? originalName : displayName;
                
                // TODO: [映射] 基础映射
                channelNameMapping.put(finalDisplayName, originalNameForMapping);
                
                // TODO: [映射] QuPath标准C索引映射
                // TODO: [修复] 使用原始索引与measurement一致
                String channelIndex = "C" + (i + 1);
                channelNameMapping.put(finalDisplayName + "_INDEX", channelIndex);
                
                // TODO: [调试] 连续C索引映射
                String consecutiveIndex = "C" + analysisChannelIndex;
                channelNameMapping.put(finalDisplayName + "_CONSECUTIVE", consecutiveIndex);
                
                logger.info("✓ 通道映射: '{}' -> 原始: '{}', C索引: '{}', 连续索引: '{}'", 
                           finalDisplayName, originalNameForMapping, channelIndex, consecutiveIndex);
            }
            
            logger.info("=== 通道分析完成 ===");
            logger.info("可用分析通道数: {}", availableChannels.size());
            
        } else {
            // TODO: [默认] 无图像时默认通道
            availableChannels.clear();
            availableChannels.addAll(Arrays.asList("FITC", "TRITC", "Cy5", "AF647", "PE"));
            
            this.channelNameMapping = new HashMap<>();
            for (String channel : availableChannels) {
                channelNameMapping.put(channel, channel);
            }
        }
        
        // 详细的映射调试信息
        logger.info("=== 最终通道映射表 ===");
        for (Map.Entry<String, String> entry : channelNameMapping.entrySet()) {
            logger.info("  映射: '{}' -> '{}'", entry.getKey(), entry.getValue());
        }
        logger.info("=== 映射表结束 ===");
    }
    
    // TODO: [方法] 调试可用measurement名称
    private void debugAvailableMeasurements(ImageData<?> imageData) {
        try {
            var hierarchy = imageData.getHierarchy();
            var detections = hierarchy.getDetectionObjects();
            if (!detections.isEmpty()) {
                var firstCell = detections.iterator().next();
                var measurements = firstCell.getMeasurementList();
                var measurementNames = measurements.getNames();
                
                logger.info("=== 实际Measurement名称列表 ===");
                for (String name : measurementNames) {
                    if (name.toLowerCase().contains("mean") || 
                        name.toLowerCase().contains("median") || 
                        name.toLowerCase().contains("max") || 
                        name.toLowerCase().contains("min")) {
                        logger.info("  Measurement: '{}'", name);
                    }
                }
                logger.info("=== Measurement列表结束 ===");
            }
        } catch (Exception e) {
            logger.debug("无法获取measurement信息: {}", e.getMessage());
        }
    }
    
    
    // TODO: [方法] 解析通道测量名称
    // TODO: [方法] 存储Load Object Classifier分类结果
    private void storeClassificationMapping(String cellId, String classificationName) {
        classificationMapping.put(cellId, classificationName);
        logger.debug("Stored classification mapping: {} -> {}", cellId, classificationName);
    }

    // TODO: [方法] 获取细胞分类名称
    private String getClassificationName(String cellId) {
        return classificationMapping.getOrDefault(cellId, "");
    }

    // TODO: [方法] 检查细胞是否有分类数据
    private boolean hasClassificationData(String cellId) {
        return classificationMapping.containsKey(cellId) && !classificationMapping.get(cellId).isEmpty();
    }

    // TODO: [方法] 获取有效通道名称
    private String getEffectiveChannelName(String channelName, String measurementType) {
        // Primary: try original channel name mapping
        String originalName = channelNameMapping.getOrDefault(channelName, channelName);
        String primaryMeasurement = originalName + ": " + measurementType.split(": ")[1];

        // Check if measurement exists in current image data
        ImageData<?> imageData = qupath.getImageData();
        if (imageData != null) {
            var allObjects = imageData.getHierarchy().getDetectionObjects();
            if (!allObjects.isEmpty()) {
                var sampleObject = allObjects.iterator().next();
                var measurements = sampleObject.getMeasurementList();

                // Try primary measurement name
                if (measurements.containsKey(primaryMeasurement)) {
                    return originalName;
                }

                // Fallback: try display name
                String fallbackMeasurement = channelName + ": " + measurementType.split(": ")[1];
                if (measurements.containsKey(fallbackMeasurement)) {
                    return channelName;
                }

                // Fallback: try variations of the channel name
                String[] variations = {originalName.toLowerCase(), originalName.toUpperCase(),
                                     channelName.toLowerCase(), channelName.toUpperCase()};
                for (String variation : variations) {
                    String testMeasurement = variation + ": " + measurementType.split(": ")[1];
                    if (measurements.containsKey(testMeasurement)) {
                        return variation;
                    }
                }
            }
        }

        // Default fallback
        return originalName;
    }
    
    // TODO: [方法] 获取图像动态范围
    private double[] getImageDynamicRange() {
        ImageData<?> imageData = qupath.getImageData();
        if (imageData != null && imageData.getServer() != null) {
            // Try to get actual range from measurements
            var hierarchy = imageData.getHierarchy();
            var cells = hierarchy.getDetectionObjects();
            if (!cells.isEmpty()) {
                var firstCell = cells.iterator().next();
                var measurements = firstCell.getMeasurementList();
                
                // Find min/max from actual measurements
                double minValue = Double.MAX_VALUE;
                double maxValue = Double.MIN_VALUE;
                
                for (String measurementName : measurements.getNames()) {
                    if (measurementName.contains("Mean") || measurementName.contains("Median")) {
                        for (var cell : cells.stream().limit(1000).collect(java.util.stream.Collectors.toList())) {
                            try {
                                double value = cell.getMeasurementList().get(measurementName);
                                if (!Double.isNaN(value) && !Double.isInfinite(value)) {
                                    minValue = Math.min(minValue, value);
                                    maxValue = Math.max(maxValue, value);
                                }
                            } catch (Exception e) {
                                // Continue with next measurement
                            }
                        }
                    }
                }
                
                if (minValue != Double.MAX_VALUE && maxValue != Double.MIN_VALUE) {
                    // Add some padding
                    double range = maxValue - minValue;
                    return new double[]{Math.max(0, minValue - range * 0.1), maxValue + range * 0.1};
                }
            }
            
            // Fallback: Use image bit depth
            var server = imageData.getServer();
            int bitDepth = 8; // Default
            try {
                if (server.getPixelType().toString().contains("UINT16")) {
                    bitDepth = 16;
                } else if (server.getPixelType().toString().contains("FLOAT32")) {
                    return new double[]{0, 1.0}; // Float images typically 0-1
                }
            } catch (Exception e) {
                logger.debug("Could not determine bit depth, using default");
            }
            
            double maxVal = Math.pow(2, bitDepth) - 1;
            return new double[]{0, maxVal};
        }
        
        // Ultimate fallback
        return new double[]{0, 65535}; // 16-bit range
    }
    
    // TODO: [方法] 创建对数滑块
    private Slider createLogarithmicSlider(double minVal, double maxVal, double defaultVal, String channelName) {
        // Ensure positive values for log scale
        double logMin = Math.log10(Math.max(1, minVal));
        double logMax = Math.log10(Math.max(2, maxVal));
        double logDefault = Math.log10(Math.max(1, defaultVal));
        
        Slider slider = new Slider(logMin, logMax, logDefault);
        
        // Store reference first to avoid lookup issues
        thresholdSliders.put(channelName, slider);
        
        return slider;
    }
    
    // TODO: [方法] 从对数滑块获取线性值
    private double getLinearValue(Slider logSlider) {
        return Math.pow(10, logSlider.getValue());
    }
    
    // TODO: [方法] 待优化方法

    private void initializeThresholds() {
        Map<String, ThresholdConfig.ChannelThreshold> thresholds = new HashMap<>();
        for (int i = 0; i < availableChannels.size(); i++) {
            String channelName = availableChannels.get(i);
            double defaultThreshold = i == 0 ? 150.0 : 100.0; // First channel enabled by default
            boolean enabled = i == 0;
            thresholds.put(channelName, new ThresholdConfig.ChannelThreshold("Nucleus: Mean", defaultThreshold, enabled));
        }

        for (Map.Entry<String, ThresholdConfig.ChannelThreshold> entry : thresholds.entrySet()) {
            currentConfig = currentConfig.withChannelThreshold(entry.getKey(), entry.getValue());
        }
    }
    
    // TODO: [方法] 待优化方法

    public void show() {
        if (stage != null) {
            stage.toFront();
            return;
        }

        // Refresh channel information when showing
        loadAvailableChannels();
        initializeThresholds();

        stage = new Stage();
        stage.setTitle("CycBiOx");
        stage.initModality(Modality.NONE);
        stage.initOwner(qupath.getStage());

        ScrollPane scrollPane = createMainLayout();
        // 优化GUI宽度，适合数据展示的紧凑设计
        Scene scene = new Scene(scrollPane, 800, 750);
        stage.setScene(scene);
        stage.show();

        // Initialize cell selection highlighting mechanism
        initializeCellSelectionHighlighting();

        stage.setOnCloseRequest(e -> {
            // Clear any preview when closing
            clearLivePreview();
            // Clean up selection listener
            cleanupSelectionHighlighting();
            stage = null;
        });
    }
    
    // TODO: [方法] 待优化方法

    private ScrollPane createMainLayout() {
        VBox root = new VBox(10);
        root.setPadding(new Insets(10));

        // Basic settings section
        root.getChildren().add(createBasicSettingsSection());

        // Threshold strategy section
        TitledPane thresholdPane = new TitledPane("阈值策略配置", createOptimizedThresholdSection());
        thresholdPane.setCollapsible(false);
        root.getChildren().add(thresholdPane);

        // Cell classification section
        root.getChildren().add(createClassificationSection());

        // Action buttons
        root.getChildren().add(createActionButtonsSection());

        ScrollPane scrollPane = new ScrollPane(root);
        scrollPane.setFitToWidth(true);
        scrollPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        scrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);

        return scrollPane;
    }
    
    // TODO: [UI] 创建紧凑基础设置区域
    private VBox createCompactBasicSettings() {
        VBox section = new VBox(5);
        section.setPadding(new Insets(8));
        section.setStyle("-fx-background-color: #f8f9fa; -fx-border-color: #dee2e6; -fx-border-radius: 5; -fx-padding: 8;");
        
        // 标题
        Label titleLabel = new Label("基础设置");
        titleLabel.setStyle("-fx-font-weight: bold; -fx-font-size: 14px; -fx-text-fill: #495057;");
        section.getChildren().add(titleLabel);
        
        // 设置内容 - 水平排列以节省空间
        HBox settingsBox = new HBox(15);
        settingsBox.setAlignment(Pos.CENTER_LEFT);

        // 配置名称
        VBox nameBox = new VBox(3);
        Label nameLabel = new Label("配置名称");
        nameLabel.setStyle("-fx-font-size: 11px; -fx-text-fill: #6c757d;");
        configNameField = new TextField("默认配置");
        configNameField.setPrefWidth(120);
        nameBox.getChildren().addAll(nameLabel, configNameField);


        // 保存地址
        VBox pathBox = new VBox(3);
        Label pathLabel = new Label("保存地址");
        pathLabel.setStyle("-fx-font-size: 11px; -fx-text-fill: #6c757d;");
        savePathField = new TextField(System.getProperty("user.home"));
        savePathField.setPrefWidth(200);
        Button browseButton = new Button("...");
        browseButton.setPrefWidth(30);
        browseButton.setOnAction(e -> browseSavePath(savePathField));
        HBox pathControls = new HBox(5);
        pathControls.getChildren().addAll(savePathField, browseButton);
        pathBox.getChildren().addAll(pathLabel, pathControls);

        // 分析细胞下拉框
        VBox cellAnalysisBox = new VBox(3);
        Label cellAnalysisLabel = new Label("分析细胞");
        cellAnalysisLabel.setStyle("-fx-font-size: 11px; -fx-text-fill: #6c757d;");
        cellAnalysisComboBox = new ComboBox<>();
        cellAnalysisComboBox.getItems().addAll("当前选中细胞", "全部细胞");
        cellAnalysisComboBox.setValue("全部细胞");
        cellAnalysisComboBox.setPrefWidth(120);
        cellAnalysisBox.getChildren().addAll(cellAnalysisLabel, cellAnalysisComboBox);
        
        return section;
    }
    
    // TODO: [UI] 创建优化阈值策略区域 - 上下布局
    private VBox createOptimizedThresholdSection() {
        VBox section = new VBox(8);
        section.setPadding(new Insets(10));
        section.setStyle("-fx-background-color: #ffffff; -fx-border-color: #dee2e6; -fx-border-radius: 5;");

        // 标题
        Label titleLabel = new Label("阈值策略配置");
        titleLabel.setStyle("-fx-font-weight: bold; -fx-font-size: 16px; -fx-text-fill: #495057;");
        section.getChildren().add(titleLabel);

        // 1. 确定通道阳性阈值（CREATE模式）
        HBox createBox = new HBox(10);
        createBox.setAlignment(Pos.CENTER_LEFT);
        createBox.setPadding(new Insets(5));
        Label createLabel = new Label("确定通道阳性阈值:");
        createLabel.setStyle("-fx-font-weight: bold; -fx-font-size: 12px;");
        RadioButton createRadio = new RadioButton();
        createRadio.setSelected(currentMode == OperationMode.CREATE_CLASSIFIER);
        createBox.getChildren().addAll(createRadio, createLabel);

        // 2. 刷新通道
        HBox refreshBox = new HBox(10);
        refreshBox.setAlignment(Pos.CENTER_LEFT);
        refreshBox.setPadding(new Insets(5));
        refreshButton = new Button("刷新通道");
        refreshButton.setStyle("-fx-background-color: #17a2b8; -fx-text-fill: white; -fx-font-size: 11px;");
        refreshButton.setOnAction(e -> refreshChannels());

        // 添加刷新通道的适用场景说明
        Label refreshHintLabel = new Label("(适用场景: 图像切换、通道重命名、导入新数据后)");
        refreshHintLabel.setStyle("-fx-font-size: 10px; -fx-text-fill: #6c757d; -fx-font-style: italic;");

        refreshBox.getChildren().addAll(refreshButton, refreshHintLabel);

        // 3. 阈值策略
        HBox strategyBox = new HBox(10);
        strategyBox.setAlignment(Pos.CENTER_LEFT);
        strategyBox.setPadding(new Insets(5));
        Label strategyLabel = new Label("阈值策略:");
        strategyLabel.setStyle("-fx-font-size: 12px;");
        strategyComboBox = new ComboBox<>();
        strategyComboBox.getItems().addAll(ThresholdConfig.Strategy.values());

        // 设置StringConverter来显示中文名称
        strategyComboBox.setConverter(new StringConverter<ThresholdConfig.Strategy>() {
            @Override
            public String toString(ThresholdConfig.Strategy strategy) {
                return strategy != null ? strategy.getDisplayName() : "";
            }

            @Override
            public ThresholdConfig.Strategy fromString(String string) {
                for (ThresholdConfig.Strategy strategy : ThresholdConfig.Strategy.values()) {
                    if (strategy.getDisplayName().equals(string)) {
                        return strategy;
                    }
                }
                return null;
            }
        });

        strategyComboBox.setValue(currentConfig.getStrategy());
        strategyComboBox.setPrefWidth(100);

        // 算法选择框 - 自动模式时显示（添加中文名称和解释）
        algorithmComboBox = new ComboBox<>();
        algorithmComboBox.getItems().addAll(
            "MaxEntropy (最大熵算法-适用于复杂背景)",
            "Triangle (三角算法-适用于双峰分布)",
            "Otsu (大津算法-经典双峰分割)",
            "Minimum (最小值算法-适用于明暗差异大)"
        );
        algorithmComboBox.setValue("MaxEntropy (最大熵算法-适用于复杂背景)");
        algorithmComboBox.setPrefWidth(200);
        algorithmComboBox.setStyle("-fx-font-size: 9px;");
        algorithmComboBox.setVisible(false);

        // 计算按钮 - Auto模式时显示
        calculateButton = new Button("计算");
        calculateButton.setStyle("-fx-background-color: #ffc107; -fx-text-fill: white; -fx-font-size: 10px; -fx-padding: 3 8 3 8;");
        calculateButton.setVisible(false);
        calculateButton.setOnAction(e -> {
            String algorithmDisplay = algorithmComboBox.getValue();
            String algorithm = extractAlgorithmName(algorithmDisplay);
            calculateAutoThresholds(algorithm);
        });

        // 根据策略下拉框选择显示/隐藏算法选择和计算按钮
        strategyComboBox.setOnAction(e -> {
            ThresholdConfig.Strategy selectedStrategy = strategyComboBox.getValue();
            isAutoMode = (selectedStrategy == ThresholdConfig.Strategy.AUTO);

            // 更新配置中的策略设置，确保状态同步
            currentConfig = currentConfig.withStrategy(selectedStrategy);

            logger.info("阈值策略切换: {}", isAutoMode ? "自动" : "手动");

            // 显示/隐藏算法选择和计算按钮
            algorithmComboBox.setVisible(isAutoMode);
            calculateButton.setVisible(isAutoMode);

            if (isAutoMode) {
                logger.info("自动模式已激活 - 请选择算法并点击计算按钮");
            } else {
                logger.info("切换到手动模式，保持已计算的阈值不变");
            }

            updateControlStatesForMode();
        });

        strategyBox.getChildren().addAll(strategyLabel, strategyComboBox, algorithmComboBox, calculateButton);

        // 4. 选择所需通道，执行策略（LOAD模式）
        HBox loadBox = new HBox(10);
        loadBox.setAlignment(Pos.CENTER_LEFT);
        loadBox.setPadding(new Insets(5));
        Label loadLabel = new Label("选择所需通道，执行策略:");
        loadLabel.setStyle("-fx-font-weight: bold; -fx-font-size: 12px;");
        RadioButton loadRadio = new RadioButton();
        loadRadio.setSelected(currentMode == OperationMode.LOAD_CLASSIFIER);
        loadBox.getChildren().addAll(loadRadio, loadLabel);

        // 单选按钮组
        ToggleGroup modeGroup = new ToggleGroup();
        createRadio.setToggleGroup(modeGroup);
        loadRadio.setToggleGroup(modeGroup);

        // 切换逻辑
        modeGroup.selectedToggleProperty().addListener((observable, oldToggle, newToggle) -> {
            if (newToggle == createRadio) {
                currentMode = OperationMode.CREATE_CLASSIFIER;
                updateChannelSelectionMode();
                updateControlStatesForMode();
                updateButtonStates();
                logger.info("Switched to Create Classifier mode - Single channel selection");
            } else if (newToggle == loadRadio) {
                currentMode = OperationMode.LOAD_CLASSIFIER;
                updateChannelSelectionMode();
                updateControlStatesForMode();
                updateButtonStates();
                logger.info("Switched to Load Classifier mode - Multi-channel selection");
            }
        });

        // 5. 运行按钮
        HBox executeBox = new HBox();
        executeBox.setAlignment(Pos.CENTER_LEFT);
        executeBox.setPadding(new Insets(10, 0, 0, 0));
        executeButton = new Button("运行");
        executeButton.setStyle("-fx-background-color: #28a745; -fx-text-fill: white; -fx-font-size: 13px; -fx-font-weight: bold;");
        executeButton.setOnAction(e -> executeStrategy());
        updateButtonStates();
        executeBox.getChildren().add(executeButton);

        // 添加所有组件到垂直布局
        section.getChildren().addAll(createBox, refreshBox, strategyBox, loadBox, executeBox);
        
        // 通道控制区域 - 动态高度
        channelContainer = new VBox(3);
        createChannelControls();
        
        ScrollPane channelScrollPane = new ScrollPane(channelContainer);
        channelScrollPane.setFitToWidth(true);

        // 优化30+通道支持：动态高度计算和滚动策略
        int channelCount = availableChannels.size();
        double maxHeight;

        if (channelCount <= 4) {
            maxHeight = Math.min(calculateOptimalChannelHeight(), 280); // 少量通道，紧凑显示
        } else if (channelCount <= 15) {
            maxHeight = 350; // 中等数量通道，标准高度
        } else {
            maxHeight = 450; // 30+通道，更大的滚动区域
        }

        channelScrollPane.setPrefHeight(maxHeight);
        channelScrollPane.setMaxHeight(maxHeight);

        // 优化滚动性能和用户体验
        channelScrollPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER); // 水平不滚动
        channelScrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED); // 垂直滚动按需显示
        channelScrollPane.setPannable(true); // 支持拖拽滚动
        channelScrollPane.setVvalue(0.0); // 默认滚动到顶部
        channelScrollPane.setStyle("-fx-background-color: transparent; -fx-focus-color: transparent;");

        logger.info("通道滚动优化完成 - {}个通道，最大高度: {}px", channelCount, maxHeight);
        
        section.getChildren().add(channelScrollPane);

        // 初始按钮状态控制
        updateButtonStates();

        return section;
    }
    
    // TODO: [UI] 创建优化细胞分类区域
    private VBox createOptimizedClassificationSection() {
        VBox section = new VBox(8);
        section.setPadding(new Insets(10));
        section.setStyle("-fx-background-color: #ffffff; -fx-border-color: #dee2e6; -fx-border-radius: 5;");
        
        // 标题和右上角新增细胞按钮
        HBox headerBox = new HBox();
        headerBox.setAlignment(Pos.CENTER_RIGHT);
        headerBox.setPadding(new Insets(5, 0, 10, 0));

        Label titleLabel = new Label("细胞分类配置");
        titleLabel.setStyle("-fx-font-weight: bold; -fx-font-size: 16px; -fx-text-fill: #495057;");

        // 使用 Region spacer 将按钮推到右边
        Region spacer = new Region();
        HBox.setHgrow(spacer, javafx.scene.layout.Priority.ALWAYS);

        Button addButton = new Button("+ 新增细胞类型");
        addButton.setStyle("-fx-background-color: #2196F3; -fx-text-fill: white; -fx-font-size: 12px; -fx-font-weight: bold;");
        addButton.setOnAction(e -> addNewPhenotype());

        headerBox.getChildren().addAll(titleLabel, spacer, addButton);
        section.getChildren().add(headerBox);
        
        // 表型配置表格 - 标准布局，支持滚动
        createPhenotypeTable();

        // 表格容器 - 增强左右滚动支持30+通道
        ScrollPane tableScrollPane = new ScrollPane(phenotypeTable);
        tableScrollPane.setFitToWidth(false); // 重要：允许水平滚动，不强制适应宽度
        tableScrollPane.setFitToHeight(true);  // 垂直方向适应高度
        tableScrollPane.setPrefHeight(300);    // 标准高度
        tableScrollPane.setMaxHeight(400);     // 最大高度限制

        // 优化滚动策略 - 支持30+通道的左右滑动
        tableScrollPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED); // 水平滚动条自动显示
        tableScrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);  // 垂直滚动条自动显示

        // 设置滚动性能优化
        tableScrollPane.setPannable(true); // 支持拖拽滚动
        tableScrollPane.setStyle("-fx-background-color: transparent; -fx-focus-color: transparent;");

        // 强制表格不适应ScrollPane宽度，使其能够水平滚动
        phenotypeTable.autosize();
        phenotypeTable.setColumnResizePolicy(TableView.UNCONSTRAINED_RESIZE_POLICY);

        section.getChildren().add(tableScrollPane);

        logger.info("细胞分类界面优化完成 - 支持30+通道的左右滑动显示");
        return section;
    }
    
    // TODO: [方法] 待优化方法

    private TitledPane createBasicSettingsSection() {
        VBox content = new VBox(10);
        content.setPadding(new Insets(10));

        // Configuration name
        HBox nameBox = new HBox(10);
        nameBox.setAlignment(Pos.CENTER_LEFT);
        Label nameLabel = new Label("配置名称");
        nameLabel.setPrefWidth(80);
        configNameField = new TextField(currentConfig.getConfigName());
        configNameField.setPrefWidth(200);
        nameBox.getChildren().addAll(nameLabel, configNameField);

        // Save path selection
        HBox pathBox = new HBox(10);
        pathBox.setAlignment(Pos.CENTER_LEFT);
        Label pathLabel = new Label("保存地址");
        pathLabel.setPrefWidth(80);
        savePathField = new TextField(System.getProperty("user.home"));
        savePathField.setPrefWidth(200);
        Button browseButton = new Button("浏览...");
        browseButton.setOnAction(e -> browseSavePath(savePathField));
        HBox pathControls = new HBox(5);
        pathControls.getChildren().addAll(savePathField, browseButton);
        pathBox.getChildren().addAll(pathLabel, pathControls);


        // Cell analysis selection with statistics
        VBox cellAnalysisBox = new VBox(5);

        // Main selection row
        HBox cellSelectionRow = new HBox(10);
        cellSelectionRow.setAlignment(Pos.CENTER_LEFT);
        Label cellAnalysisLabel = new Label("分析细胞");
        cellAnalysisLabel.setPrefWidth(80);
        cellAnalysisComboBox = new ComboBox<>();
        cellAnalysisComboBox.getItems().addAll("当前选中细胞", "全部细胞");
        cellAnalysisComboBox.setValue("全部细胞");
        cellAnalysisComboBox.setPrefWidth(200);
        cellSelectionRow.getChildren().addAll(cellAnalysisLabel, cellAnalysisComboBox);

        // Statistics display
        HBox statisticsRow = new HBox(10);
        statisticsRow.setAlignment(Pos.CENTER_LEFT);
        Label spacerLabel = new Label(); // 占位符保持对齐
        spacerLabel.setPrefWidth(80);
        Label statisticsLabel = new Label("统计信息: 加载中...");
        statisticsLabel.setStyle("-fx-font-size: 10px; -fx-text-fill: #666666;");
        statisticsRow.getChildren().addAll(spacerLabel, statisticsLabel);

        cellAnalysisBox.getChildren().addAll(cellSelectionRow, statisticsRow);

        // Update statistics when selection changes
        cellAnalysisComboBox.setOnAction(e -> updateStatisticsDisplay(statisticsLabel));

        // Initialize statistics display
        updateStatisticsDisplay(statisticsLabel);

        content.getChildren().addAll(nameBox, pathBox, cellAnalysisBox);

        TitledPane pane = new TitledPane("基本设置", content);
        pane.setCollapsible(false);
        return pane;
    }
    
    
    /**
     * 根据通道数量计算最优的界面高度 - 标准布局策略
     */
    private double calculateOptimalChannelHeight() {
        int channelCount = availableChannels.size();
        if (channelCount == 0) return 120; // 空状态最小高度
        
        // 标准布局：每个通道固定高度
        double heightPerChannel = 50; // 紧凑的通道行高度
        double headerHeight = 35;     // 表头高度
        double paddingHeight = 20;    // 上下padding
        
        // 计算基础高度
        double totalHeight = headerHeight + (channelCount * heightPerChannel) + paddingHeight;
        
        // 标准布局策略：
        // 1-4个通道：显示全部，无滚动
        // 5-8个通道：适中高度，轻度滚动 
        // 9+个通道：固定高度，滚动浏览
        double finalHeight;
        if (channelCount <= 4) {
            finalHeight = totalHeight; // 显示全部
        } else if (channelCount <= 8) {
            finalHeight = Math.min(totalHeight, 300); // 适中高度
        } else {
            finalHeight = 350; // 固定较大高度，支持滚动
        }
        
        logger.info("标准布局高度计算: {}个通道 -> {}px ({})", 
                   channelCount, finalHeight, 
                   channelCount <= 4 ? "无滚动" : channelCount <= 8 ? "轻度滚动" : "标准滚动");
        return finalHeight;
    }
    
    /**
     * 根据通道数量优化整体布局
     */
    private void optimizeLayoutForChannels() {
        int channelCount = availableChannels.size();
        
        // 根据通道数量调整各个区域的比例
        Platform.runLater(() -> {
            // 更新通道区域高度
            if (channelContainer != null && channelContainer.getParent() instanceof ScrollPane) {
                ScrollPane scrollPane = (ScrollPane) channelContainer.getParent();
                double newHeight = calculateOptimalChannelHeight();
                scrollPane.setPrefHeight(newHeight);
                
                // 优化滚动策略
                if (channelCount <= 4) {
                    scrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
                } else {
                    scrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);
                }
                
                logger.debug("已更新通道区域布局: {}个通道, 高度{}px", channelCount, newHeight);
            }
        });
    }
    
    // TODO: [方法] 待优化方法

    private void createChannelControls() {
        channelContainer.getChildren().clear();
        channelRadioButtons.clear();
        channelCheckBoxes.clear();
        measurementComboBoxes.clear();
        thresholdSliders.clear();
        thresholdFields.clear();
        thresholdStatusLabels.clear();
        
        // Clear toggle groups
        if (singleChannelGroup != null) {
            singleChannelGroup.getToggles().clear();
        }
        singleChannelGroup = new ToggleGroup();
        
        // Header with columns for both modes
        HBox header = new HBox(10);
        header.setPadding(new Insets(8));
        header.setStyle("-fx-background-color: #e3f2fd; -fx-border-color: #90caf9; -fx-border-radius: 3;");

        // 选择列（CREATE和LOAD模式都显示）
        Label loadSelectionLabel = new Label("选择");
        loadSelectionLabel.setPrefWidth(50);
        loadSelectionLabel.setStyle("-fx-font-weight: bold; -fx-font-size: 11px;");
        // 选择列在两种模式下都显示

        // 通道列
        Label channelLabel = new Label("通道");
        channelLabel.setPrefWidth(80);
        channelLabel.setStyle("-fx-font-weight: bold; -fx-font-size: 11px;");

        // 预览列（CREATE和LOAD模式都显示）
        Label previewLabel = new Label("预览");
        previewLabel.setPrefWidth(50);
        previewLabel.setStyle("-fx-font-weight: bold; -fx-font-size: 11px;");
        // 预览列在两种模式下都显示

        // 测量值列
        Label measurementLabel = new Label("测量值");
        measurementLabel.setPrefWidth(130);
        measurementLabel.setStyle("-fx-font-weight: bold; -fx-font-size: 11px;");

        // 阈值列
        Label thresholdLabel = new Label("阈值");
        thresholdLabel.setPrefWidth(280); // 与内容列宽度匹配，确保按钮完整显示
        thresholdLabel.setStyle("-fx-font-weight: bold; -fx-font-size: 11px;");

        // 阈值设置状态列（位置往右移）
        Label statusLabel = new Label("设置状态");
        statusLabel.setPrefWidth(100); // 增加宽度确保正常显示
        statusLabel.setStyle("-fx-font-weight: bold; -fx-font-size: 11px;");

        header.getChildren().addAll(loadSelectionLabel, channelLabel, previewLabel, measurementLabel, thresholdLabel, statusLabel);
        channelContainer.getChildren().add(header);
        
        // Create controls for each channel
        for (String channelName : availableChannels) {
            HBox channelBox = createChannelRow(channelName);
            channelContainer.getChildren().add(channelBox);
        }
    }
    
    private HBox createChannelRow(String channelName) {
        HBox row = new HBox(10);
        row.setPadding(new Insets(5));
        row.setAlignment(Pos.CENTER_LEFT);

        // 1. 选择列（使用统一的选择逻辑）
        CheckBox loadSelectionCheckBox = new CheckBox();
        loadSelectionCheckBox.setPrefWidth(50);

        // 先将CheckBox添加到Map，然后通过统一方法设置状态
        channelCheckBoxes.put(channelName, loadSelectionCheckBox);

        // 使用统一的状态更新逻辑
        updateChannelSelectionStatus(channelName);

        row.getChildren().add(loadSelectionCheckBox);

        // 2. 通道列
        Label channelLabel = new Label(channelName);
        channelLabel.setPrefWidth(80);
        channelLabel.setStyle("-fx-font-weight: bold; -fx-font-size: 11px;");

        // Add tooltip if channel name was modified
        String originalName = channelNameMapping.get(channelName);
        if (originalName != null && !originalName.equals(channelName)) {
            Tooltip tooltip = new Tooltip(String.format("Original: %s\nDisplay: %s", originalName, channelName));
            tooltip.setShowDelay(javafx.util.Duration.millis(300));
            channelLabel.setTooltip(tooltip);
            channelLabel.setStyle("-fx-font-weight: bold; -fx-text-fill: #1976D2;"); // Blue color for modified names
        }
        row.getChildren().add(channelLabel);

        // 3. 预览列（两种模式都显示，仅CREATE模式可操作）
        RadioButton previewRadio = new RadioButton();
        previewRadio.setPrefWidth(50);
        previewRadio.setToggleGroup(singleChannelGroup);

        if (currentMode == OperationMode.CREATE_CLASSIFIER) {
            // CREATE模式：可操作
            previewRadio.setDisable(false);
            previewRadio.setStyle(""); // 正常样式
        } else {
            // LOAD模式：显示但不可操作，灰色
            previewRadio.setDisable(true);
            previewRadio.setSelected(false); // 确保不被选中
            previewRadio.setStyle("-fx-opacity: 0.6;"); // 视觉上显示为灰色
        }

        previewRadio.setOnAction(e -> {
            if (previewRadio.isSelected() && currentMode == OperationMode.CREATE_CLASSIFIER) {
                clearLivePreview();
                currentPreviewChannel = channelName;
                livePreviewEnabled = true;

                // 如果该通道已确认阈值，自动加载保存的设置并应用预览
                if (isChannelThresholdConfirmed(channelName)) {
                    loadSavedThresholdAndPreview(channelName);
                } else {
                    // 如果没有确认阈值，启用实时预览（滑块变化时预览）
                    logger.info("Selected channel for Create Classifier (no saved threshold): {}", channelName);
                }

                logger.info("Selected channel for Create Classifier: {}", channelName);
            }
        });

        channelRadioButtons.put(channelName, previewRadio);
        row.getChildren().add(previewRadio);

        // 4. 测量值列
        ThresholdConfig.ChannelThreshold channelThreshold = currentConfig.getChannelThresholds().get(channelName);

        ComboBox<String> measurementCombo = new ComboBox<>();
        measurementCombo.getItems().addAll(MEASUREMENT_TYPES);

        // Preserve existing measurement type from configuration
        String existingMeasurement = "Nucleus: Mean"; // Default value
        if (channelThreshold != null) {
            existingMeasurement = channelThreshold.getMeasurement();
        }

        measurementCombo.setValue(existingMeasurement);
        measurementCombo.setPrefWidth(130);

        // Load模式下禁用measurement选择
        measurementCombo.setDisable(currentMode == OperationMode.LOAD_CLASSIFIER);

        measurementCombo.setOnAction(e -> {
            if (livePreviewEnabled && channelName.equals(currentPreviewChannel)) {
                updateLivePreview();
            }
            // Update status when measurement changes
            updateThresholdStatus(channelName, false);
        });
        measurementComboBoxes.put(channelName, measurementCombo);
        row.getChildren().add(measurementCombo);

        // 5. 阈值列
        VBox thresholdBox = new VBox(5);

        // Create logarithmic slider with dynamic range based on image bit depth
        double[] range = getImageDynamicRange();

        // Preserve existing threshold value from configuration
        double existingThreshold = 100; // Default value
        if (channelThreshold != null) {
            existingThreshold = channelThreshold.getThreshold();
        }
        
        Slider slider = createLogarithmicSlider(range[0], range[1], existingThreshold, channelName);
        slider.setPrefWidth(140); // 进一步减少滑块宽度以适应按钮

        // Load模式下禁用阈值滑块
        slider.setDisable(currentMode == OperationMode.LOAD_CLASSIFIER);

        TextField textField = new TextField(String.format("%.1f", existingThreshold));
        textField.setPrefWidth(50); // 减少文本框宽度

        // Load模式下禁用阈值文本框
        textField.setDisable(currentMode == OperationMode.LOAD_CLASSIFIER);

        thresholdFields.put(channelName, textField);
        
        // Bind slider and text field with live preview (logarithmic handling)
        slider.valueProperty().addListener((obs, oldVal, newVal) -> {
            // Update text field with linear value from logarithmic slider
            double linearValue = getLinearValue(slider);
            textField.setText(String.format("%.1f", linearValue));
            
            if (livePreviewEnabled && channelName.equals(currentPreviewChannel)) {
                // Debounce live preview updates for better performance
                Platform.runLater(() -> updateLivePreview());
            }
        });
        
        textField.setOnAction(e -> {
            try {
                double val = Double.parseDouble(textField.getText());
                // Convert linear value to logarithmic scale
                double logVal = Math.log10(Math.max(1, val));
                slider.setValue(logVal);
                if (livePreviewEnabled && channelName.equals(currentPreviewChannel)) {
                    updateLivePreview();
                }
            } catch (NumberFormatException ex) {
                textField.setText(String.format("%.1f", getLinearValue(slider)));
            }
        });
        
        HBox sliderBox = new HBox(3); // 减少元素间间距以节省空间
        sliderBox.getChildren().addAll(slider, textField);
        sliderBox.setAlignment(Pos.CENTER_LEFT);
        
        // Add confirm button for Create Classifier mode - for live preview and threshold saving
        if (currentMode == OperationMode.CREATE_CLASSIFIER) {
            Button confirmButton = new Button("确定");
            confirmButton.setStyle("-fx-background-color: #2196F3; -fx-text-fill: white; -fx-font-size: 10px;");
            confirmButton.setPrefWidth(45); // 调整按钮宽度适应布局
            confirmButton.setMinWidth(45);
            confirmButton.setMaxWidth(45);
            confirmButton.setOnAction(e -> confirmChannelThreshold(channelName));

            sliderBox.getChildren().add(confirmButton);
        }

        thresholdBox.getChildren().add(sliderBox);
        thresholdBox.setPrefWidth(280); // 进一步增加阈值列总宽度确保所有元素完整显示
        row.getChildren().add(thresholdBox);

        // 6. 阈值设置状态列（与标题对应的宽度）
        Label statusLabel = new Label("未设置");
        statusLabel.setPrefWidth(100); // 与标题对应的宽度
        statusLabel.setStyle("-fx-background-color: #FF9800; -fx-text-fill: white; -fx-font-size: 10px; -fx-alignment: center; -fx-padding: 4px;");

        thresholdStatusLabels.put(channelName, statusLabel);
        row.getChildren().add(statusLabel);

        return row;
    }

    /**
     * Extract algorithm name from display string with Chinese explanation
     * @param algorithmDisplay Display string like "Triangle (三角算法-适用于双峰分布)"
     * @return Algorithm name like "Triangle"
     */
    private String extractAlgorithmName(String algorithmDisplay) {
        if (algorithmDisplay == null) return "Triangle";
        // Extract the part before the first space and parenthesis
        int spaceIndex = algorithmDisplay.indexOf(' ');
        if (spaceIndex > 0) {
            return algorithmDisplay.substring(0, spaceIndex);
        }
        return algorithmDisplay; // Fallback to original if no space found
    }

    /**
     * Check if a channel's threshold has been confirmed
     * @param channelName The channel name to check
     * @return true if the threshold has been confirmed, false otherwise
     */
    private boolean isChannelThresholdConfirmed(String channelName) {
        Label statusLabel = thresholdStatusLabels.get(channelName);
        if (statusLabel != null) {
            // 检查状态标签文本是否为"已设置"
            return "已设置".equals(statusLabel.getText());
        }
        return false;
    }

    /**
     * Update channel selection checkbox status based on threshold confirmation
     * @param channelName The channel name to update
     */
    private void updateChannelSelectionStatus(String channelName) {
        CheckBox selectionCheckBox = channelCheckBoxes.get(channelName);
        if (selectionCheckBox != null) {
            boolean isThresholdConfirmed = isChannelThresholdConfirmed(channelName);

            // 无论什么模式，只要阈值确认了，就保存为CREATE模式选择状态（用于LOAD模式读取）
            if (isThresholdConfirmed && !createModeSelections.containsKey(channelName)) {
                createModeSelections.put(channelName, true); // 默认选中已确认的通道
            }

            if (currentMode == OperationMode.CREATE_CLASSIFIER) {
                // CREATE模式：阈值确认后自动勾选并禁用
                if (isThresholdConfirmed) {
                    selectionCheckBox.setSelected(true);
                    selectionCheckBox.setDisable(true);
                    selectionCheckBox.setStyle("-fx-opacity: 0.8;"); // 已确认状态

                    // 保存CREATE模式的选择状态
                    createModeSelections.put(channelName, true);
                } else {
                    selectionCheckBox.setSelected(false);
                    selectionCheckBox.setDisable(true);
                    selectionCheckBox.setStyle("-fx-opacity: 0.6;"); // 未确认状态

                    // 保存CREATE模式的选择状态
                    createModeSelections.put(channelName, false);
                }
            } else {
                // LOAD模式：阈值确认的可手动操作，未确认的禁用
                if (isThresholdConfirmed) {
                    // 读取CREATE模式保存的选择状态，如果没有则默认选中
                    boolean shouldSelect = createModeSelections.getOrDefault(channelName, true);
                    selectionCheckBox.setSelected(shouldSelect);
                    selectionCheckBox.setDisable(false);
                    selectionCheckBox.setStyle(""); // 正常样式

                    logger.debug("LOAD模式通道 {}: 阈值已确认={}, 选择状态={}", channelName, isThresholdConfirmed, shouldSelect);
                } else {
                    selectionCheckBox.setSelected(false);
                    selectionCheckBox.setDisable(true);
                    selectionCheckBox.setStyle("-fx-opacity: 0.6;"); // 禁用样式

                    logger.debug("LOAD模式通道 {}: 阈值未确认，禁用选择", channelName);
                }
            }
        }
    }

    /**
     * Update statistics display for cell analysis selection
     * @param statisticsLabel The label to update
     */
    private void updateStatisticsDisplay(Label statisticsLabel) {
        try {
            ImageData<?> imageData = qupath.getImageData();
            if (imageData == null) {
                statisticsLabel.setText("统计信息: 无图像数据");
                return;
            }

            var hierarchy = imageData.getHierarchy();
            var allCells = hierarchy.getDetectionObjects();
            var selectedROIs = hierarchy.getSelectionModel().getSelectedObjects()
                    .stream()
                    .filter(obj -> obj.getROI() != null && obj.isAnnotation())
                    .collect(Collectors.toList());

            String selectedMode = cellAnalysisComboBox != null ? cellAnalysisComboBox.getValue() : "全部细胞";

            if ("当前选中细胞".equals(selectedMode)) {
                if (selectedROIs.isEmpty()) {
                    statisticsLabel.setText("统计信息: 未选中ROI区域，将分析全部 " + allCells.size() + " 个细胞");
                } else {
                    // Count cells within selected ROIs
                    int cellsInROI = 0;
                    for (var cell : allCells) {
                        for (var roi : selectedROIs) {
                            if (roi.getROI().contains(cell.getROI().getCentroidX(), cell.getROI().getCentroidY())) {
                                cellsInROI++;
                                break;
                            }
                        }
                    }
                    statisticsLabel.setText("统计信息: 已选中 " + selectedROIs.size() + " 个ROI区域，包含 " + cellsInROI + " 个细胞");
                }
            } else {
                statisticsLabel.setText("统计信息: 将分析全部 " + allCells.size() + " 个细胞");
            }
        } catch (Exception e) {
            statisticsLabel.setText("统计信息: 获取统计信息失败");
            logger.warn("Failed to update statistics display: {}", e.getMessage());
        }
    }

    /**
     * Update threshold status for a channel
     * @param channelName The channel name
     * @param isSet Whether the threshold has been set (green) or not (orange)
     */
    private void updateThresholdStatus(String channelName, boolean isSet) {
        Label statusLabel = thresholdStatusLabels.get(channelName);
        if (statusLabel != null) {
            if (isSet) {
                statusLabel.setText("已设置");
                statusLabel.setStyle("-fx-background-color: #28a745; -fx-text-fill: white; -fx-font-size: 10px; -fx-alignment: center; -fx-padding: 4px;");
            } else {
                statusLabel.setText("未设置");
                statusLabel.setStyle("-fx-background-color: #FF9800; -fx-text-fill: white; -fx-font-size: 10px; -fx-alignment: center; -fx-padding: 4px;");
            }
        }
    }

    /**
     * Confirm channel threshold setting and apply live preview
     */
    private void confirmChannelThreshold(String channelName) {
        // Check if this channel is selected
        if (currentMode == OperationMode.CREATE_CLASSIFIER) {
            RadioButton radioButton = channelRadioButtons.get(channelName);
            if (radioButton == null || !radioButton.isSelected()) {
                showAlert(Alert.AlertType.WARNING, "提示", "请先选择通道 " + channelName);
                return;
            }
        }
        
        ImageData<?> imageData = qupath.getImageData();
        if (imageData == null) {
            showAlert(Alert.AlertType.WARNING, "警告", "没有图像数据可用于预览");
            return;
        }
        
        Slider slider = thresholdSliders.get(channelName);
        ComboBox<String> measurementBox = measurementComboBoxes.get(channelName);
        
        if (slider != null && measurementBox != null) {
            double threshold = getLinearValue(slider);  // Convert from log scale
            String measurementType = measurementBox.getValue();
            
            // Save threshold setting to configuration
            ThresholdConfig.ChannelThreshold channelThreshold = new ThresholdConfig.ChannelThreshold(measurementType, threshold, true);
            currentConfig = currentConfig.withChannelThreshold(channelName, channelThreshold);
            
            // Apply live preview using unified method
            updateLivePreview();

            // Update status to "已设置" (green)
            updateThresholdStatus(channelName, true);

            // Update selection checkbox status after threshold confirmation
            updateChannelSelectionStatus(channelName);

            logger.info("Confirmed threshold for channel {}: threshold={}, measurement={}",
                channelName, threshold, measurementType);
        }
    }
    

    /**
     * 加载已保存的阈值设置并应用预览
     * Load saved threshold settings and apply preview for confirmed channels
     * @param channelName The channel name to load saved settings for
     */
    private void loadSavedThresholdAndPreview(String channelName) {
        ThresholdConfig.ChannelThreshold savedThreshold = currentConfig.getChannelThresholds().get(channelName);
        if (savedThreshold == null) {
            logger.warn("No saved threshold found for channel: {}", channelName);
            return;
        }

        try {
            // 更新滑块到保存的阈值位置
            Slider slider = thresholdSliders.get(channelName);
            TextField textField = thresholdFields.get(channelName);
            ComboBox<String> measurementBox = measurementComboBoxes.get(channelName);

            if (slider != null && textField != null && measurementBox != null) {
                // 设置测量值类型
                measurementBox.setValue(savedThreshold.getMeasurement());

                // 设置阈值（转换为对数刻度）
                double logValue = Math.log10(Math.max(1, savedThreshold.getThreshold()));
                slider.setValue(logValue);
                textField.setText(String.format("%.1f", savedThreshold.getThreshold()));

                // 应用预览效果 - 直接调用更新预览
                Platform.runLater(() -> {
                    updateLivePreview();
                });

                logger.info("Loaded saved threshold for channel {}: threshold={}, measurement={}",
                    channelName, savedThreshold.getThreshold(), savedThreshold.getMeasurement());
            }
        } catch (Exception e) {
            logger.error("Failed to load saved threshold for channel {}: {}", channelName, e.getMessage());
        }
    }

    /**
     * Find actual measurement name from possible alternatives
     * ENHANCED BOTTOM LAYER CHANNEL NAME MATCHING for user-modified channels
     */
    private String findActualMeasurementName(List<qupath.lib.objects.PathObject> cells, String[] possibleNames, String channelName) {
        if (cells.isEmpty()) return null;
        
        var firstCell = cells.get(0);
        var measurements = firstCell.getMeasurementList();
        List<String> availableNames = measurements.getNames();
        
        logger.info("BOTTOM LAYER MATCHING - Channel: '{}', Total measurements available: {}", channelName, availableNames.size());
        
        // Try exact matches from possibleNames first
        for (String testName : possibleNames) {
            if (measurements.containsKey(testName)) {
                logger.info("Found exact measurement match for channel '{}': {}", channelName, testName);
                return testName;
            }
        }
        
        // ENHANCED C2/C3/C4 STRATEGY: Multiple mapping approaches for QuPath measurements
        String originalChannelName = channelNameMapping.getOrDefault(channelName, channelName);
        String channelIndex = channelNameMapping.getOrDefault(channelName + "_INDEX", "");
        
        // Debug log all available measurements containing channel-like patterns
        logger.info("C2/C3/C4 PATTERN MATCHING - Display: '{}', Original: '{}', Index: '{}'", 
                   channelName, originalChannelName, channelIndex);
        logger.info("Available measurements containing any channel patterns:");
        availableNames.stream()
            .filter(name -> name.toLowerCase().contains(channelName.toLowerCase()) || 
                           name.toLowerCase().contains(originalChannelName.toLowerCase()) ||
                           (!channelIndex.isEmpty() && name.toLowerCase().contains(channelIndex.toLowerCase())))
            .forEach(name -> logger.info("  -> {}", name));
        
        // Strategy 1: ENHANCED patterns including C2/C3/C4 (highest priority)
        List<String> patternList = new ArrayList<>();
        if (!channelIndex.isEmpty()) {
            patternList.add(channelIndex);  // C2, C3, C4... (highest priority for QuPath)
        }
        patternList.add(originalChannelName);     // Original channel name from metadata
        patternList.add(channelName);             // Current display name (user-modified)
        
        String[] patterns = patternList.toArray(new String[0]);
        String[] measurementTypes = {"Mean", "Median", "Max", "Min"};
        
        for (String pattern : patterns) {
            // Exact pattern matching
            for (String availableName : availableNames) {
                if (availableName.contains(pattern + ":")) {
                    logger.info("Found bottom layer exact match for channel '{}': {} (pattern: {})", 
                               channelName, availableName, pattern);
                    return availableName;
                }
            }
            
            // Pattern with measurement type matching
            for (String measurementType : measurementTypes) {
                for (String availableName : availableNames) {
                    String expectedName = pattern + ": " + measurementType;
                    String expectedName2 = measurementType + ": " + pattern;
                    String expectedName3 = "Nucleus: " + pattern + ": " + measurementType;
                    String expectedName4 = "Cell: " + pattern + ": " + measurementType;
                    String expectedName5 = "Cytoplasm: " + pattern + ": " + measurementType;
                    
                    if (availableName.equals(expectedName) || availableName.equals(expectedName2) ||
                        availableName.equals(expectedName3) || availableName.equals(expectedName4) ||
                        availableName.equals(expectedName5)) {
                        logger.info("Found bottom layer pattern match for channel '{}': {} (pattern: {}, type: {})", 
                                   channelName, availableName, pattern, measurementType);
                        return availableName;
                    }
                }
            }
        }
        
        // Strategy 2: Case-insensitive bottom layer matching
        for (String pattern : patterns) {
            for (String availableName : availableNames) {
                if (availableName.toLowerCase().contains(pattern.toLowerCase() + ":") ||
                    availableName.toLowerCase().contains(":" + pattern.toLowerCase())) {
                    logger.info("Found case-insensitive bottom layer match for channel '{}': {} (pattern: {})", 
                               channelName, availableName, pattern);
                    return availableName;
                }
            }
        }
        
        // Strategy 3: Substring matching with measurement types
        for (String pattern : patterns) {
            for (String measurementType : measurementTypes) {
                for (String availableName : availableNames) {
                    if (availableName.toLowerCase().contains(pattern.toLowerCase()) &&
                        availableName.toLowerCase().contains(measurementType.toLowerCase())) {
                        logger.info("Found bottom layer substring match for channel '{}': {} (pattern: {}, type: {})", 
                                   channelName, availableName, pattern, measurementType);
                        return availableName;
                    }
                }
            }
        }
        
        // Strategy 4: Fallback with partial name matching (minimum 3 characters)
        for (String pattern : patterns) {
            if (pattern.length() >= 3) {
                String partialPattern = pattern.substring(0, Math.min(pattern.length(), 6));
                for (String availableName : availableNames) {
                    if (availableName.toLowerCase().contains(partialPattern.toLowerCase()) &&
                        availableName.toLowerCase().contains("mean")) {
                        logger.info("Found bottom layer partial match for channel '{}': {} (partial: {})", 
                                   channelName, availableName, partialPattern);
                        return availableName;
                    }
                }
            }
        }
        
        // Strategy 5: CRITICAL FALLBACK - Use first measurement containing channel name
        String criticalFallback = availableNames.stream()
            .filter(name -> name.toLowerCase().contains(channelName.toLowerCase()) && 
                           name.toLowerCase().contains("mean"))
            .findFirst()
            .orElse(null);
            
        if (criticalFallback != null) {
            logger.warn("Using critical fallback measurement for channel '{}': {}", channelName, criticalFallback);
            return criticalFallback;
        }
        
        // List available measurements for debugging
        logger.warn("Bottom layer matching failed for channel: '{}' (original: '{}'). Available measurements:", 
                   channelName, originalChannelName);
        availableNames.stream()
                     .sorted()
                     .limit(20) // Show first 20 to avoid spam
                     .forEach(name -> logger.warn("  - {}", name));
        
        return null;
    }
    
    /**
     * Sync QuPath display data including markers, annotations, and detections - ENHANCED for pseudo-coloring
     */
    private void syncQuPathDisplayData(ImageData<?> imageData) {
        try {
            var hierarchy = imageData.getHierarchy();
            
            // CRITICAL: Fire hierarchy change events to update displays
            hierarchy.fireHierarchyChangedEvent(null);
            
            // ENHANCED: Multiple update mechanisms for robust pseudo-color display
            if (qupath.getViewer() != null) {
                var viewer = qupath.getViewer();
                
                // Update overlay options first to ensure color mapping is refreshed
                var overlayOptions = viewer.getOverlayOptions();
                if (overlayOptions != null) {
                    // Reset measurement mapper to refresh display
                    overlayOptions.resetMeasurementMapper();
                }
                
                // Force overlay updates before repaint
                viewer.forceOverlayUpdate();
                
                // Force complete viewer repaint
                viewer.repaint();
                
                // ADDITIONAL: Force complete viewer refresh for color changes
                try {
                    // Multiple repaint strategies for robust color display
                    viewer.repaint();
                    // Additional repaint with slight delay to ensure colors are applied
                    Platform.runLater(() -> viewer.repaint());
                } catch (Exception displayEx) {
                    logger.debug("Viewer repaint failed: {}", displayEx.getMessage());
                }
            }
            
            // Additional hierarchy update to ensure all listeners are notified
            Platform.runLater(() -> {
                try {
                    hierarchy.fireHierarchyChangedEvent(null);
                    if (qupath.getViewer() != null) {
                        qupath.getViewer().repaint();
                    }
                    logger.debug("Delayed pseudo-color display update completed");
                } catch (Exception delayedEx) {
                    logger.debug("Delayed display update failed (non-critical): {}", delayedEx.getMessage());
                }
            });
            
        } catch (Exception e) {
            logger.error("Error syncing QuPath display data: {}", e.getMessage(), e);
        }
    }
    
    /**
     * Update channel selection mode based on current operation mode
     */
    private void updateChannelSelectionMode() {
        // Clear any existing preview
        clearLivePreview();

        // 直接更新控件状态，不重新创建控件（避免丢失状态）
        updateControlStatesForMode();

        // Update instruction label if it exists
        channelContainer.getChildren().stream()
            .filter(node -> node instanceof HBox)
            .map(node -> (HBox) node)
            .flatMap(hbox -> hbox.getChildren().stream())
            .filter(node -> node instanceof Label)
            .map(node -> (Label) node)
            .filter(label -> label.getStyle().contains("italic"))
            .findFirst()
            .ifPresent(this::updateInstructionLabel);

        logger.info("Channel selection mode updated for: {} - {}",
            currentMode,
            currentMode == OperationMode.CREATE_CLASSIFIER ? "Single channel selection" : "Multi-channel selection");
    }

    /**
     * 计算并保存所有通道的Auto阈值
     */
    // TODO: [方法] 待优化方法

    private void calculateAutoThresholds(String algorithm) {
        ImageData<?> imageData = qupath.getImageData();
        if (imageData == null) {
            showAlert(Alert.AlertType.WARNING, "警告", "无图像数据，无法计算Auto阈值");
            return;
        }

        try {
            var hierarchy = imageData.getHierarchy();
            var cells = hierarchy.getDetectionObjects();
            if (cells.isEmpty()) {
                showAlert(Alert.AlertType.WARNING, "警告", "无细胞数据，无法计算Auto阈值");
                return;
            }

            logger.info("开始使用{}算法为 {} 个通道计算自动阈值", algorithm, availableChannels.size());

            Platform.runLater(() -> {
                try {
                    int calculatedCount = 0;
                    for (String channelName : availableChannels) {
                        double threshold = calculateThresholdForChannel(channelName, algorithm, cells);
                        if (threshold > 0) {
                            // 保存Auto计算的阈值
                            savedAutoThresholds.put(channelName, threshold);

                            // 更新显示
                            updateThresholdDisplay(channelName, threshold);

                            // 重要：更新ThresholdConfig中的阈值设置，使Create模式能够使用这些阈值
                            updateConfigThreshold(channelName, threshold);

                            // 更新阈值状态为"已设置"
                            updateThresholdStatus(channelName, true);

                            // 更新选择列状态（CREATE模式自动勾选，LOAD模式按保存状态）
                            updateChannelSelectionStatus(channelName);

                            calculatedCount++;
                            logger.info("通道 '{}' {}算法阈值: {} (已更新到配置)", channelName, algorithm, threshold);
                        }
                    }

                    if (calculatedCount > 0) {
                        logger.info("✅ 成功使用{}算法计算了{}个通道的阈值并更新到配置", algorithm, calculatedCount);
                        // 计算完成后，禁用measurement和threshold控件
                        updateControlStatesForMode();
                    } else {
                        logger.warn("⚠️ 未能计算出有效的阈值，请检查数据");
                    }

                } catch (Exception e) {
                    logger.error("自动阈值计算失败: {}", e.getMessage(), e);
                }
            });

        } catch (Exception e) {
            logger.error("自动阈值计算失败: {}", e.getMessage(), e);
            showAlert(Alert.AlertType.ERROR, "计算错误", "阈值计算失败: " + e.getMessage());
        }
    }

    /**
     * 为单个通道计算阈值
     */
    private double calculateThresholdForChannel(String channelName, String algorithm, Collection<qupath.lib.objects.PathObject> cells) {
        try {
            // 关键修复：使用智能匹配避免CD31误匹配到CD3
            var firstCell = cells.iterator().next();
            var measurements = firstCell.getMeasurementList();

            // 策略1: 使用智能匹配函数
            String measurementName = findMeasurementNameForClassification(
                measurements,
                channelName,
                "Nucleus: Mean"
            );

            logger.info("✅ {} 阈值计算匹配结果: '{}' -> measurement '{}'",
                       channelName, channelName, measurementName);

            if (measurementName != null) {
                List<Double> values = new ArrayList<>();
                for (var cell : cells) {
                    try {
                        double value = cell.getMeasurementList().get(measurementName);
                        if (!Double.isNaN(value) && value > 0) {
                            values.add(value);
                        }
                    } catch (Exception e) {
                        // 忽略单个细胞的读取错误
                    }
                }

                if (values.size() > 10) { // 至少需要10个有效值
                    return calculateThresholdByAlgorithm(values, algorithm);
                }
            }
        } catch (Exception e) {
            logger.debug("通道 '{}' 阈值计算失败: {}", channelName, e.getMessage());
        }

        return 0.0;
    }

    /**
     * 根据算法计算阈值
     */
    private double calculateThresholdByAlgorithm(List<Double> values, String algorithm) {
        switch (algorithm) {
            case "Otsu":
                return calculateOtsuThreshold(values);
            case "Triangle":
                return calculateTriangleThreshold(values);
            case "MaxEntropy":
                return calculateMaxEntropyThreshold(values);
            case "Minimum":
                return calculateMinimumThreshold(values);
            default:
                return calculateOtsuThreshold(values); // 默认使用Otsu
        }
    }

    private void calculateAndSaveAutoThresholds() {
        ImageData<?> imageData = qupath.getImageData();
        if (imageData == null) {
            logger.warn("无图像数据，无法计算Auto阈值");
            return;
        }

        try {
            var hierarchy = imageData.getHierarchy();
            var cells = hierarchy.getDetectionObjects();
            if (cells.isEmpty()) {
                logger.warn("无细胞数据，无法计算Auto阈值");
                return;
            }

            logger.info("开始为 {} 个通道计算Auto阈值", availableChannels.size());

            for (String channelName : availableChannels) {
                try {
                    // 关键修复：使用智能匹配避免CD31误匹配到CD3
                    var firstCell = cells.iterator().next();
                    var measurements = firstCell.getMeasurementList();

                    // 策略1: 使用智能匹配函数
                    String measurementName = findMeasurementNameForClassification(
                        measurements,
                        channelName,
                        "Nucleus: Mean"
                    );

                    logger.info("✅ {} Auto阈值计算匹配结果: '{}' -> measurement '{}'",
                               channelName, channelName, measurementName);

                    if (measurementName != null) {
                        List<Double> values = new ArrayList<>();
                        for (var cell : cells) {
                            try {
                                double value = cell.getMeasurementList().get(measurementName);
                                if (!Double.isNaN(value) && !Double.isInfinite(value)) {
                                    values.add(value);
                                }
                            } catch (Exception e) {
                                // 忽略无效值
                            }
                        }

                        if (!values.isEmpty()) {
                            double otsuThreshold = calculateOtsuThreshold(values);
                            savedAutoThresholds.put(channelName, otsuThreshold);

                            // 更新界面显示
                            updateThresholdDisplay(channelName, otsuThreshold);

                            logger.info("通道 '{}' Auto阈值计算完成: {}", channelName, otsuThreshold);
                        }
                    }
                } catch (Exception e) {
                    logger.error("计算通道 '{}' 的Auto阈值失败: {}", channelName, e.getMessage());
                }
            }

            logger.info("Auto阈值计算完成，共处理 {} 个通道，成功计算 {} 个",
                    availableChannels.size(), savedAutoThresholds.size());

            // 如果有选中的预览通道，触发预览更新
            if (livePreviewEnabled && currentPreviewChannel != null) {
                updateLivePreview();
            }

        } catch (Exception e) {
            logger.error("Auto阈值计算过程出错: {}", e.getMessage());
        }
    }

    /**
     * 更新阈值显示控件
     */
    private void updateThresholdDisplay(String channelName, double threshold) {
        TextField thresholdField = thresholdFields.get(channelName);
        Slider thresholdSlider = thresholdSliders.get(channelName);

        if (thresholdField != null) {
            thresholdField.setText(String.format("%.2f", threshold));
        }

        if (thresholdSlider != null) {
            // 转换为对数值设置滑块
            double logValue = Math.log10(Math.max(1, threshold));
            thresholdSlider.setValue(logValue);
        }
    }

    /**
     * 更新ThresholdConfig中的阈值设置
     */
    private void updateConfigThreshold(String channelName, double threshold) {
        try {
            // 获取当前通道的实际measurement名称
            String measurementName = null;

            // 首先尝试从现有的ComboBox中获取选中的measurement名称
            ComboBox<String> measurementCombo = measurementComboBoxes.get(channelName);
            if (measurementCombo != null && measurementCombo.getValue() != null) {
                measurementName = measurementCombo.getValue();
            } else {
                // 如果没有ComboBox或没有选择，使用默认的Nucleus Mean
                measurementName = "Nucleus: " + channelName + ": Mean";

                // 尝试查找可用的measurement名称
                ImageData<?> imageData = qupath.getImageData();
                if (imageData != null) {
                    var cells = imageData.getHierarchy().getDetectionObjects();
                    if (!cells.isEmpty()) {
                        String foundMeasurement = findMeasurementNameForClassification(
                            cells.iterator().next().getMeasurementList(),
                            channelName,
                            "Nucleus: Mean"
                        );
                        if (foundMeasurement != null) {
                            measurementName = foundMeasurement;
                        }
                    }
                }
            }

            // 创建新的ChannelThreshold
            ThresholdConfig.ChannelThreshold channelThreshold =
                new ThresholdConfig.ChannelThreshold(measurementName, threshold, true);

            // 更新配置
            currentConfig = currentConfig.withChannelThreshold(channelName, channelThreshold);

            logger.info("已更新配置：通道 '{}' 使用measurement '{}' 阈值设为 {}",
                       channelName, measurementName, threshold);

        } catch (Exception e) {
            logger.error("更新配置阈值失败 - 通道: {}, 阈值: {}, 错误: {}", channelName, threshold, e.getMessage());
        }
    }

    /**
     * 更新控件状态根据当前模式
     */
    private void updateControlStatesForMode() {
        boolean isLoadMode = (currentMode == OperationMode.LOAD_CLASSIFIER);
        boolean isAutoMode = (currentConfig != null && currentConfig.getStrategy() == ThresholdConfig.Strategy.AUTO);

        // Load模式下禁用通道阈值策略、刷新通道控件
        if (strategyComboBox != null) {
            strategyComboBox.setDisable(isLoadMode);
        }
        if (refreshButton != null) {
            refreshButton.setDisable(isLoadMode);
        }

        // Load模式下禁用算法选择和计算按钮
        if (algorithmComboBox != null) {
            algorithmComboBox.setDisable(isLoadMode);
        }
        if (calculateButton != null) {
            calculateButton.setDisable(isLoadMode);
        }

        // 为所有通道的控件设置状态
        for (String channelName : availableChannels) {
            ComboBox<String> measurementCombo = measurementComboBoxes.get(channelName);
            Slider thresholdSlider = thresholdSliders.get(channelName);
            TextField thresholdField = thresholdFields.get(channelName);
            CheckBox channelCheckBox = channelCheckBoxes.get(channelName);
            RadioButton channelRadioButton = channelRadioButtons.get(channelName);

            // 更新选择列状态 - 使用新的智能选择逻辑
            updateChannelSelectionStatus(channelName);

            // 更新预览列状态
            if (channelRadioButton != null) {
                if (isLoadMode) {
                    // LOAD模式：显示但不可操作，灰色
                    channelRadioButton.setDisable(true);
                    channelRadioButton.setSelected(false);
                    channelRadioButton.setStyle("-fx-opacity: 0.6;"); // 视觉上显示为灰色
                } else {
                    // CREATE模式：可操作
                    channelRadioButton.setDisable(false);
                    channelRadioButton.setStyle(""); // 正常样式
                }
            }

            if (measurementCombo != null) {
                // Load模式或Auto模式下禁用measurement选择
                measurementCombo.setDisable(isLoadMode || isAutoMode);
                if (isAutoMode) {
                    measurementCombo.setStyle("-fx-opacity: 0.6;"); // 设置灰色外观
                } else {
                    measurementCombo.setStyle(""); // 恢复正常外观
                }
            }
            if (thresholdSlider != null) {
                // Load模式或Auto模式下禁用阈值滑块
                thresholdSlider.setDisable(isLoadMode || isAutoMode);
                if (isAutoMode) {
                    thresholdSlider.setStyle("-fx-opacity: 0.6;"); // 设置灰色外观
                } else {
                    thresholdSlider.setStyle(""); // 恢复正常外观
                }
            }
            if (thresholdField != null) {
                // Load模式或Auto模式下禁用阈值文本框
                thresholdField.setDisable(isLoadMode || isAutoMode);
                if (isAutoMode) {
                    thresholdField.setStyle("-fx-opacity: 0.6;"); // 设置灰色外观
                } else {
                    thresholdField.setStyle(""); // 恢复正常外观
                }
            }
        }

        // 设置算法和计算控件的灰色外观
        if (algorithmComboBox != null && isLoadMode) {
            algorithmComboBox.setStyle("-fx-opacity: 0.6;");
        } else if (algorithmComboBox != null) {
            algorithmComboBox.setStyle("");
        }

        if (calculateButton != null && isLoadMode) {
            calculateButton.setStyle("-fx-background-color: #cccccc; -fx-text-fill: #666666; -fx-font-size: 12px;");
        } else if (calculateButton != null && !isLoadMode) {
            calculateButton.setStyle("-fx-background-color: #FF9800; -fx-text-fill: white; -fx-font-size: 12px;");
        }

        logger.info("控件状态更新完成 - Load模式: {}, Auto模式: {}", isLoadMode, isAutoMode);
    }
    
    /**
     * Update instruction label based on current mode
     */
    private void updateInstructionLabel(Label instructionLabel) {
        if (currentMode == OperationMode.CREATE_CLASSIFIER) {
            instructionLabel.setText("Create模式: 单选通道进行实时预览 (阳性=紫色, 阴性=灰色)");
        } else {
            instructionLabel.setText("Load模式: 多选通道进行完整分类加载");
        }
    }

    private void refreshChannels() {
        // Preserve current channel mapping before reload
        Map<String, String> previousMapping = new HashMap<>(channelNameMapping);
        
        // Reload channels from current image data
        loadAvailableChannels();
        
        // Restore mapping for channels that still exist
        for (String channelName : availableChannels) {
            if (previousMapping.containsKey(channelName)) {
                channelNameMapping.put(channelName, previousMapping.get(channelName));
            }
        }
        
        // Reinitialize thresholds with preserved or new defaults
        initializeThresholds();
        
        // Recreate channel controls with updated mapping
        createChannelControls();
        
        // Also refresh the phenotype table columns
        if (phenotypeTable != null) {
            createPhenotypeTable();
        }
        
        logger.info("Refreshed channels with preserved mapping. Active channels: {}, Mappings: {}", 
                   availableChannels.size(), channelNameMapping.size());
    }
    
    // TODO: [方法] 待优化方法

    private void executeStrategy() {
        ImageData<?> imageData = qupath.getImageData();
        if (imageData == null) {
            showAlert(Alert.AlertType.WARNING, "警告", "没有可用的图像数据!");
            return;
        }
        
        if (currentMode == OperationMode.CREATE_CLASSIFIER) {
            // Create模式点击执行策略时提示需要进行Load处理
            Alert alert = new Alert(Alert.AlertType.INFORMATION);
            alert.setTitle("执行策略提示");
            alert.setHeaderText("Create模式仅用于预览");
            alert.setContentText("Create模式是用于预览和设置阈值的。\n\n" +
                                "要执行实际的分类策略，请：\n" +
                                "1. 切换到 'Load Classifier (Execute Strategy)' 模式\n" +
                                "2. 选择需要的通道\n" +
                                "3. 点击执行策略进行实际分类\n\n" +
                                "这是因为分类需要按照 Create → Load 的顺序处理。");
            alert.showAndWait();
            return;
        } else {
            // Check if any channels are enabled for Load Classifier mode
            boolean hasEnabled = channelCheckBoxes.values().stream()
                .anyMatch(CheckBox::isSelected);
            if (!hasEnabled) {
                showAlert(Alert.AlertType.WARNING, "提示", "Load Classifier模式需要启用至少一个通道!");
                return;
            }
            executeLoadClassifierMode(imageData);
        }
    }
    
    private void previewChannel(String channelName) {
        logger.info("Activating live preview for channel: {}", channelName);
        // Clear any existing preview when switching channels
        clearPreview();
        // Apply threshold preview for the selected channel
        Slider slider = thresholdSliders.get(channelName);
        if (slider != null) {
            previewThreshold(channelName, getLinearValue(slider));  // Convert from log scale
        }
    }
    
    private void previewThreshold(String channelName, double threshold) {
        ImageData<?> imageData = qupath.getImageData();
        if (imageData == null) {
            logger.warn("No image data available for preview");
            return;
        }
        
        // Only preview if in Create Classifier mode
        if (currentMode != OperationMode.CREATE_CLASSIFIER) {
            return;
        }
        
        logger.info("Live preview: {} > {}", channelName, threshold);
        
        try {
            // Apply threshold directly to cells for live preview
            var hierarchy = imageData.getHierarchy();
            var cells = new ArrayList<>(hierarchy.getDetectionObjects());
            
            // Clear existing preview classifications first
            clearPreview();
            
            final int[] counts = new int[2]; // [positive, negative]
            String measurementType = measurementComboBoxes.get(channelName).getValue();

            // === 修复Build 12: 使用精确匹配而不是简单拼接 ===
            // 先从第一个cell获取measurement名称（使用增强匹配逻辑）
            String measurementName = null;
            if (!cells.isEmpty()) {
                var sampleCell = cells.get(0);
                measurementName = findMeasurementNameForClassification(
                    sampleCell.getMeasurementList(), channelName, measurementType);
            }

            if (measurementName == null) {
                logger.error("❌ Live Preview失败: 无法找到通道 '{}' 的measurement", channelName);
                return;
            }

            logger.info("✅ Live Preview使用measurement: '{}'", measurementName);

            for (var cell : cells) {
                try {
                    var measurements = cell.getMeasurementList();
                    if (measurements.containsKey(measurementName)) {
                        double measurementValue = measurements.get(measurementName);
                        boolean isPositive = measurementValue > threshold;
                        
                        if (isPositive) {
                            // Set preview color for positive cells (purple/magenta)
                            cell.setColor(0xFF00FF); // Magenta for positive
                            counts[0]++;
                        } else {
                            // Set preview color for negative cells (gray)
                            cell.setColor(0x808080); // Gray for negative
                            counts[1]++;
                        }
                    }
                } catch (Exception e) {
                    logger.debug("Could not process cell {}: {}", cell.getID(), e.getMessage());
                }
            }
            
            // Update the display with enhanced zoom-independent method
            Platform.runLater(() -> {
                // Force hierarchy update first
                hierarchy.fireHierarchyChangedEvent(null);

                // Use enhanced viewer update for zoom-independent display
                updateViewerForAllZoomLevels();

                // Show preview status
                String status = String.format("Preview %s: %d positive, %d negative (threshold: %.1f)",
                    channelName, counts[0], counts[1], threshold);
                showPreviewStatus(status);
            });
            
        } catch (Exception e) {
            logger.error("Error during live preview: {}", e.getMessage(), e);
        }
    }

    private void clearPreview() {
        ImageData<?> imageData = qupath.getImageData();
        if (imageData == null) return;
        
        // Performance optimization for large datasets
        var hierarchy = imageData.getHierarchy();
        var allCells = new ArrayList<>(hierarchy.getDetectionObjects());
        
        // Clear all cells - high-performance 10M+ support with parallel processing
        logger.info("Clearing preview colors for {} cells using parallel processing", allCells.size());
        allCells.parallelStream().forEach(cell -> {
            cell.setColor(null); // Reset to default QuPath coloring
        });
        
        Platform.runLater(() -> {
            if (qupath.getViewer() != null) {
                qupath.getViewer().repaint();
            }
        });
    }
    
    private void showPreviewStatus(String status) {
        // Show status in QuPath status bar if available
        Platform.runLater(() -> {
            if (qupath.getStage() != null) {
                try {
                    // Try to update QuPath's status display
                    qupath.getStage().setTitle("QuPath - " + status);
                } catch (Exception e) {
                    // Fallback to console logging
                    logger.info("Live Preview Status: {}", status);
                }
            } else {
                logger.info("Live Preview Status: {}", status);
            }
        });
    }
    
    /**
     * Enhanced viewer update for zoom-independent cell display
     * 改进的查看器更新，支持所有缩放级别的细胞显示
     */
    private void updateViewerForAllZoomLevels() {
        try {
            if (qupath.getViewer() != null) {
                var viewer = qupath.getViewer();
                var overlayOptions = viewer.getOverlayOptions();

                if (overlayOptions != null) {
                    // 保持现有的细胞显示模式设置，不强制覆盖用户的选择
                    // 只确保检测可见性和填充设置
                    overlayOptions.setShowDetections(true);
                    overlayOptions.setFillDetections(true);
                    overlayOptions.resetMeasurementMapper();
                }

                // Force overlay update before repaint
                viewer.forceOverlayUpdate();
                viewer.repaint();

                logger.debug("Enhanced viewer update completed - zoom-independent display enabled");
            }
        } catch (Exception e) {
            logger.debug("Enhanced viewer update failed (non-critical): {}", e.getMessage());
        }
    }

    /**
     * Clear Live Preview mode and reset channel button styles
     */
    private void clearLivePreview() {
        livePreviewEnabled = false;
        currentPreviewChannel = null;
        
        // Reset all channel button styles to inactive
        channelContainer.getChildren().forEach(child -> {
            if (child instanceof HBox) {
                HBox childRow = (HBox) child;
                if (!childRow.getChildren().isEmpty() && childRow.getChildren().get(0) instanceof Button) {
                    Button btn = (Button) childRow.getChildren().get(0);
                    if (!btn.getText().equals("Channel")) { // Skip header
                        btn.setStyle("-fx-font-weight: bold; -fx-background-color: #e0e0e0; -fx-text-fill: black;");
                    }
                }
            }
        });
        
        // Clear preview coloring
        clearPreview();

        // Update display with enhanced method
        updateViewerForAllZoomLevels();

        logger.info("Live Preview deactivated");
    }
    
    /**
     * Update live preview with current threshold settings - Optimized for large datasets
     */
    private void updateLivePreview() {
        if (!livePreviewEnabled || currentPreviewChannel == null) {
            return;
        }
        
        ImageData<?> imageData = qupath.getImageData();
        if (imageData == null) {
            logger.warn("No image data available for live preview update");
            return;
        }
        
        // Get current threshold for the preview channel
        Slider slider = thresholdSliders.get(currentPreviewChannel);
        ComboBox<String> measurementBox = measurementComboBoxes.get(currentPreviewChannel);
        
        if (slider != null && measurementBox != null) {
            double threshold = getLinearValue(slider);  // Convert from log scale
            String measurementType = measurementBox.getValue();
            
            // Apply live preview with ROI support and optimization for large datasets
            try {
                var hierarchy = imageData.getHierarchy();
                
                // Use ROI-filtered cells if ROI mode is enabled
                List<qupath.lib.objects.PathObject> targetCells;
                if (useSelectedROI) {
                    targetCells = getCellsInSelectedROI(imageData);
                    logger.info("Live Preview: Using {} ROI-filtered cells for channel: {}", 
                               targetCells.size(), currentPreviewChannel);
                } else {
                    targetCells = new ArrayList<>(hierarchy.getDetectionObjects());
                    logger.info("Live Preview: Using {} total cells for channel: {}", 
                               targetCells.size(), currentPreviewChannel);
                }
                
                // Process all cells - true 10M+ support without artificial limits
                var cells = targetCells;
                
                logger.info("Live Preview: Processing {} cells for channel: {}", 
                    cells.size(), currentPreviewChannel);
                
                // Clear existing preview first
                clearPreview();
                
                final int[] counts = new int[2]; // [positive, negative]
                
                // === 关键修复Build 11: 智能匹配CD31避免误匹配到CD3 ===
                // 使用findMeasurementNameForClassification确保精确匹配
                final String[] actualMeasurementName = {null};
                boolean measurementFound = false;

                if (!cells.isEmpty()) {
                    var firstCell = cells.get(0);
                    var measurements = firstCell.getMeasurementList();

                    // 策略1: 直接精确匹配（用户选择的完整measurement名称）
                    if (measurementType != null && measurements.containsKey(measurementType)) {
                        actualMeasurementName[0] = measurementType;
                        measurementFound = true;
                        logger.info("✅ 直接匹配成功: '{}' for channel '{}'", measurementType, currentPreviewChannel);
                    } else {
                        // 策略2: 使用智能匹配避免CD31误匹配到CD3
                        String matchedMeasurement = findMeasurementNameForClassification(
                            measurements, currentPreviewChannel, measurementType
                        );
                        if (matchedMeasurement != null) {
                            actualMeasurementName[0] = matchedMeasurement;
                            measurementFound = true;
                            logger.info("✅ 智能匹配成功: '{}' -> '{}' for channel '{}'",
                                       measurementType, matchedMeasurement, currentPreviewChannel);
                        } else {
                            logger.error("❌ 匹配失败: channel '{}', measurementType '{}",
                                       currentPreviewChannel, measurementType);
                            return;
                        }
                    }
                } else {
                    logger.warn("No cells available for measurement matching");
                    return;
                }

                if (!measurementFound || actualMeasurementName[0] == null) {
                    logger.error("❌ 无法为通道 '{}' 找到有效的measurement", currentPreviewChannel);
                    showPreviewStatus("错误: 无法找到通道 " + currentPreviewChannel + " 的测量数据");
                    return;
                }
                
                // High-performance parallel processing for 10M+ cells
                logger.info("Starting high-performance live preview for {} cells", cells.size());
                
                // Process cells with parallel stream for massive datasets
                cells.parallelStream().forEach(cell -> {
                    try {
                        var measurements = cell.getMeasurementList();
                        if (measurements.containsKey(actualMeasurementName[0])) {
                            double measurementValue = measurements.get(actualMeasurementName[0]);
                            boolean isPositive = measurementValue > threshold;
                            
                            if (isPositive) {
                                // Set preview color for positive cells (purple/magenta)
                                cell.setColor(0xFF00FF); // Magenta for positive
                                synchronized(counts) { counts[0]++; }
                            } else {
                                // Set preview color for negative cells (gray)
                                cell.setColor(0x808080); // Gray for negative
                                synchronized(counts) { counts[1]++; }
                            }
                        }
                    } catch (Exception e) {
                        logger.debug("Could not process cell {}: {}", cell.getID(), e.getMessage());
                    }
                });
                
                // Update the display with enhanced zoom-independent method
                Platform.runLater(() -> {
                    updateViewerForAllZoomLevels();

                    // Show preview status with performance info
                    String status = String.format("Live Preview - %s: %d阳性, %d阴性 (阈值: %.1f) [处理了%d个细胞]",
                        currentPreviewChannel, counts[0], counts[1], threshold, cells.size());
                    showPreviewStatus(status);
                });
                
            } catch (Exception e) {
                logger.error("Error during live preview update: {}", e.getMessage(), e);
            }
        }
    }
    
    /**
     * ENHANCED measurement name creation - handles ALL possible QuPath naming patterns
     */
    private String[] createPossibleMeasurementNames(String channelName, String measurementType) {
        List<String> possibleNames = new ArrayList<>();
        
        // Get all possible channel name variations
        Set<String> channelVariations = new HashSet<>();
        
        // Add current channel name
        channelVariations.add(channelName);
        
        // Add original names from mapping
        String originalName = channelNameMapping.getOrDefault(channelName, channelName);
        channelVariations.add(originalName);
        
        // Add all transformations for each base name
        for (String baseName : new String[]{channelName, originalName}) {
            if (baseName != null && !baseName.isEmpty()) {
                channelVariations.add(baseName);
                channelVariations.add(baseName.trim());
                channelVariations.add(baseName.replaceAll("\\s+", "_"));
                channelVariations.add(baseName.replaceAll("\\s+", ""));
                channelVariations.add(baseName.replaceAll("[^a-zA-Z0-9]", ""));
                channelVariations.add(baseName.toLowerCase());
                channelVariations.add(baseName.toUpperCase());
                // Add first letter uppercase
                if (baseName.length() > 0) {
                    channelVariations.add(baseName.substring(0, 1).toUpperCase() + baseName.substring(1).toLowerCase());
                }
            }
        }
        
        // Extract measurement suffix
        String measurementSuffix = "Mean"; // default
        if (measurementType.contains(":")) {
            String[] parts = measurementType.split(":");
            if (parts.length > 1) {
                measurementSuffix = parts[parts.length - 1].trim();
            }
        }
        
        // Generate comprehensive measurement patterns
        for (String channelVar : channelVariations) {
            if (channelVar == null || channelVar.isEmpty()) continue;
            
            // Core patterns - most common in QuPath
            possibleNames.add(channelVar + ": " + measurementSuffix);
            possibleNames.add(measurementSuffix + ": " + channelVar);
            
            // Nucleus variations
            possibleNames.add("Nucleus: " + channelVar + ": " + measurementSuffix);
            possibleNames.add("Nucleus: " + channelVar);
            possibleNames.add(channelVar + ": Nucleus: " + measurementSuffix);
            
            // Cell variations  
            possibleNames.add("Cell: " + channelVar + ": " + measurementSuffix);
            possibleNames.add("Cell: " + channelVar);
            possibleNames.add(channelVar + ": Cell: " + measurementSuffix);
            
            // Cytoplasm variations
            possibleNames.add("Cytoplasm: " + channelVar + ": " + measurementSuffix);
            possibleNames.add("Cytoplasm: " + channelVar);
            possibleNames.add(channelVar + ": Cytoplasm: " + measurementSuffix);
            
            // Space-based formats (no colons)
            possibleNames.add(channelVar + " " + measurementSuffix);
            possibleNames.add(measurementSuffix + " " + channelVar);
            possibleNames.add("Nucleus " + channelVar + " " + measurementSuffix);
            possibleNames.add("Cell " + channelVar + " " + measurementSuffix);
            
            // Just channel name (sometimes QuPath uses simple names)
            possibleNames.add(channelVar);
        }
        
        logger.info("Generated {} measurement name patterns for channel '{}' (type: {})", 
                   possibleNames.size(), channelName, measurementType);
        
        if (logger.isDebugEnabled()) {
            logger.debug("Channel variations: {}", channelVariations);
            logger.debug("First 10 patterns: {}", 
                possibleNames.stream().limit(10).collect(java.util.stream.Collectors.toList()));
        }
        
        return possibleNames.toArray(new String[0]);
    }
    
    // TODO: [方法] 待优化方法

    private TitledPane createClassificationSection() {
        VBox content = new VBox(10);
        content.setPadding(new Insets(10));

        // 优化布局：参考阈值策略配置的样式
        HBox headerBox = new HBox();
        headerBox.setAlignment(Pos.CENTER_RIGHT);
        headerBox.setPadding(new Insets(0, 0, 10, 0));

        Button addButton = new Button("+ 新增细胞类型");
        addButton.setStyle("-fx-background-color: #2196F3; -fx-text-fill: white; -fx-font-size: 12px; -fx-font-weight: bold;");
        addButton.setOnAction(e -> addNewPhenotype());

        headerBox.getChildren().add(addButton);

        // 表型配置表格 - 参考阈值策略配置的样式
        createPhenotypeTable();

        // 表格样式优化 - 参考阈值策略配置
        phenotypeTable.setStyle("-fx-background-color: #f5f5f5; -fx-border-color: #ddd; -fx-border-radius: 5;");

        ScrollPane tableScrollPane = new ScrollPane(phenotypeTable);
        tableScrollPane.setFitToWidth(false); // 重要：允许水平滚动
        tableScrollPane.setFitToHeight(true);

        // 自适应整个区域：移除固定高度限制，让表格自动适应可用空间
        VBox.setVgrow(tableScrollPane, Priority.ALWAYS); // 让滚动面板垂直扩展填充剩余空间
        tableScrollPane.setMaxHeight(Double.MAX_VALUE); // 移除最大高度限制

        // 优化滚动策略支持30+通道的左右滑动 - 样式参考阈值配置
        tableScrollPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);
        tableScrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);
        tableScrollPane.setPannable(true); // 支持拖拽滚动
        tableScrollPane.setStyle("-fx-background-color: #f5f5f5; -fx-border-color: #ddd; -fx-border-radius: 5; -fx-focus-color: transparent;");

        // 强制表格支持水平滚动并使用全宽度（不紧凑）
        phenotypeTable.autosize();
        phenotypeTable.setColumnResizePolicy(TableView.UNCONSTRAINED_RESIZE_POLICY); // 使用无约束策略允许水平滚动

        // 智能初始高度设置 - 与updateTableHeight()保持一致
        int cellTypeCount = Math.max(phenotypes.size(), 2); // 最少显示2行，更紧凑
        double baseRowHeight = 45; // 基础行高增加以适应新样式
        double headerHeight = 50;  // 表头高度
        double paddingHeight = 20; // 上下边距

        double initialHeight;
        if (cellTypeCount <= 3) {
            initialHeight = cellTypeCount * (baseRowHeight + 5) + headerHeight + paddingHeight;
        } else if (cellTypeCount <= 8) {
            initialHeight = cellTypeCount * baseRowHeight + headerHeight + paddingHeight;
        } else {
            double compactHeight = cellTypeCount * (baseRowHeight - 5) + headerHeight + paddingHeight;
            initialHeight = Math.min(compactHeight, 400);
        }

        tableScrollPane.setPrefHeight(initialHeight);
        if (cellTypeCount > 8) {
            tableScrollPane.setMaxHeight(400);
            tableScrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);
        } else {
            tableScrollPane.setMaxHeight(initialHeight + 10);
            tableScrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        }

        // 让表格宽度和整个宽度一样（不紧凑）
        phenotypeTable.setPrefWidth(Region.USE_COMPUTED_SIZE);
        phenotypeTable.setMaxWidth(Double.MAX_VALUE);
        phenotypeTable.setStyle("-fx-font-size: 12px;"); // 调小字体一号
        VBox.setVgrow(tableScrollPane, javafx.scene.layout.Priority.NEVER); // 不再自动扩展

        content.getChildren().addAll(headerBox, tableScrollPane);

        TitledPane pane = new TitledPane("细胞分类", content);
        pane.setCollapsible(false);

        logger.info("细胞分类界面优化完成 - 表格宽度适配整个区域");
        return pane;
    }

    /**
     * 为未分类的细胞应用灰白色伪彩
     */
    private void applyGrayColorToUnclassifiedCells(ImageData<?> imageData) {
        try {
            var hierarchy = imageData.getHierarchy();
            Collection<qupath.lib.objects.PathObject> cells = hierarchy.getDetectionObjects();

            int unclassifiedCount = 0;
            for (var cell : cells) {
                // 如果细胞没有PathClass或者PathClass为null，设置为灰白色
                if (cell.getPathClass() == null) {
                    cell.setColor(0xFFE0E0E0); // 灰白色 RGB(224, 224, 224)
                    unclassifiedCount++;
                }
            }

            // 更新显示
            hierarchy.fireHierarchyChangedEvent(null);

            if (unclassifiedCount > 0) {
                logger.info("已为{}个未分类细胞应用灰白色伪彩", unclassifiedCount);
            }

        } catch (Exception e) {
            logger.error("应用灰白色伪彩失败: {}", e.getMessage(), e);
        }
    }

    /**
     * 加载表型配置
     */
    private void loadPhenotypeConfiguration() {
        loadConfigurationFromProject();
    }

    /**
     * 保存表型配置
     */
    private void savePhenotypeConfiguration() {
        saveConfigurationToProject();
    }

    /**
     * 运行细胞分类
     */
    private void runCellClassification() {
        ImageData<?> imageData = qupath.getImageData();
        if (imageData == null) {
            showAlert(Alert.AlertType.WARNING, "警告", "没有可用的图像数据!");
            return;
        }

        if (phenotypes.isEmpty()) {
            showAlert(Alert.AlertType.WARNING, "警告", "请先添加表型定义!");
            return;
        }

        try {
            logger.info("开始运行细胞分类 - {} 个表型", phenotypes.size());

            // 使用现有的CellPhenotypeAPI进行分类
            PhenotypeManager phenotypeManager = new PhenotypeManager();
            for (CellPhenotype phenotype : phenotypes) {
                phenotypeManager.addPhenotype(phenotype);
            }

            CellPhenotypeAPI.applyCellClassification(imageData, currentConfig, phenotypeManager);

            showAlert(Alert.AlertType.INFORMATION, "分类完成",
                String.format("细胞分类完成！\n处理了 %d 个表型定义\n结果已应用到图像", phenotypes.size()));

        } catch (Exception e) {
            logger.error("细胞分类失败: {}", e.getMessage(), e);
            showAlert(Alert.AlertType.ERROR, "分类错误", "细胞分类失败: " + e.getMessage());
        }
    }

    /**
     * 导出分类结果
     */
    private void exportClassificationResults() {
        ImageData<?> imageData = qupath.getImageData();
        if (imageData == null) {
            showAlert(Alert.AlertType.WARNING, "警告", "没有可用的图像数据!");
            return;
        }

        try {
            // 选择导出文件 - 使用平台特定的文件选择器
            String defaultFileName = "cell_classification_results.csv";
            String outputPath = System.getProperty("user.home") + "/" + defaultFileName;

            // 使用现有的导出方法或创建简单导出
            try {
                var hierarchy = imageData.getHierarchy();
                var cells = hierarchy.getDetectionObjects();

                StringBuilder csvContent = new StringBuilder();
                csvContent.append("Cell_ID,X,Y,Classification,CellType\n");

                for (var cell : cells) {
                    String cellId = cell.getID().toString();
                    double x = cell.getROI().getCentroidX();
                    double y = cell.getROI().getCentroidY();
                    String classification = cell.getPathClass() != null ? cell.getPathClass().getName() : "Unclassified";
                    String cellType = classification; // 简化处理

                    csvContent.append(String.format("%s,%.2f,%.2f,%s,%s\n",
                            cellId, x, y, classification, cellType));
                }

                java.nio.file.Files.write(java.nio.file.Paths.get(outputPath), csvContent.toString().getBytes());
            } catch (Exception exportEx) {
                logger.warn("CSV导出失败，使用备用方法: {}", exportEx.getMessage());
                // 备用：只显示统计信息
                var hierarchy = imageData.getHierarchy();
                int totalCells = hierarchy.getDetectionObjects().size();

                showAlert(Alert.AlertType.INFORMATION, "导出完成",
                    String.format("分类统计：\n总细胞数: %d\n详细CSV导出功能开发中", totalCells));
                return;
            }
            showAlert(Alert.AlertType.INFORMATION, "导出完成",
                "分类结果已导出到：\n" + outputPath);
            logger.info("分类结果导出完成: {}", outputPath);
        } catch (Exception e) {
            logger.error("导出失败: {}", e.getMessage(), e);
            showAlert(Alert.AlertType.ERROR, "导出错误", "导出失败: " + e.getMessage());
        }
    }

    private void createPhenotypeTable() {
        if (phenotypeTable == null) {
            phenotypeTable = new TableView<>();
            phenotypeData = FXCollections.observableArrayList();
            phenotypeTable.setItems(phenotypeData);
        } else {
            phenotypeTable.getColumns().clear();
        }

        // 优化表格显示属性 - 无约束列宽度（支持水平滚动）
        phenotypeTable.setColumnResizePolicy(TableView.UNCONSTRAINED_RESIZE_POLICY);

        // 简洁统一的表格样式
        phenotypeTable.getStyleClass().add("compact-phenotype-table");
        phenotypeTable.setStyle(
            "-fx-font-size: 11px; " +
            "-fx-font-family: system; " +
            "-fx-background-color: white; " +
            "-fx-border-color: #d0d0d0; " +
            "-fx-border-width: 1; " +
            "-fx-border-radius: 4; " +
            // 简化表头样式
            ".column-header-background { " +
            "-fx-background-color: #f5f5f5; " +
            "-fx-border-color: #d0d0d0; " +
            "} " +
            ".column-header { " +
            "-fx-background-color: #f5f5f5; " +
            "-fx-text-fill: #333; " +
            "-fx-font-weight: bold; " +
            "-fx-font-size: 11px; " +
            "-fx-padding: 6 8 6 8; " +
            "-fx-border-color: #d0d0d0; " +
            "} " +
            ".table-column { " +
            "-fx-background-color: #f5f5f5; " +
            "-fx-text-fill: #333; " +
            "} " +
            // 简化表格行样式
            ".table-row-cell { " +
            "-fx-background-color: white; " +
            "-fx-border-color: transparent; " +
            "-fx-padding: 4 2 4 2; " +
            "} " +
            ".table-row-cell:odd { " +
            "-fx-background-color: #fafafa; " +
            "} " +
            ".table-row-cell:hover { " +
            "-fx-background-color: #f0f0f0; " +
            "} " +
            ".table-row-cell:selected { " +
            "-fx-background-color: #e8e8e8; " +
            "-fx-text-fill: #333; " +
            "} " +
            ".table-cell { " +
            "-fx-padding: 4 6 4 6; " +
            "-fx-text-fill: #333; " +
            "-fx-alignment: center; " +
            "}");

        // Priority/Sort column with up/down buttons - NULL-SAFE - 智能宽度设置
        TableColumn<PhenotypeTableRow, Integer> sortCol = new TableColumn<>("排序");
        sortCol.setCellValueFactory(new PropertyValueFactory<>("priority"));
        sortCol.setCellFactory(col -> new TableCell<PhenotypeTableRow, Integer>() {
            @Override
            protected void updateItem(Integer item, boolean empty) {
                super.updateItem(item, empty);
                if (empty) {
                    setGraphic(null);
                } else {
                    HBox sortBox = new HBox(3); // 减少间距，更紧凑
                    sortBox.setAlignment(Pos.CENTER);

                    Button upButton = new Button("↑");
                    upButton.setStyle(
                        "-fx-font-size: 11px; " +
                        "-fx-padding: 2 4 2 4; " +
                        "-fx-min-width: 20px; " +
                        "-fx-min-height: 20px; " +
                        "-fx-background-color: #f8f8f8; " +
                        "-fx-text-fill: #333; " +
                        "-fx-border-color: #ccc; " +
                        "-fx-border-width: 1; " +
                        "-fx-border-radius: 3; " +
                        "-fx-background-radius: 3; " +
                        "-fx-cursor: hand;"
                    );
                    upButton.setOnMouseEntered(e -> upButton.setStyle(
                        "-fx-font-size: 11px; " +
                        "-fx-padding: 2 4 2 4; " +
                        "-fx-min-width: 20px; " +
                        "-fx-min-height: 20px; " +
                        "-fx-background-color: #e8e8e8; " +
                        "-fx-text-fill: #333; " +
                        "-fx-border-color: #999; " +
                        "-fx-border-width: 1; " +
                        "-fx-border-radius: 3; " +
                        "-fx-background-radius: 3; " +
                        "-fx-cursor: hand;"
                    ));
                    upButton.setOnMouseExited(e -> upButton.setStyle(
                        "-fx-font-size: 11px; " +
                        "-fx-padding: 2 4 2 4; " +
                        "-fx-min-width: 20px; " +
                        "-fx-min-height: 20px; " +
                        "-fx-background-color: #f8f8f8; " +
                        "-fx-text-fill: #333; " +
                        "-fx-border-color: #ccc; " +
                        "-fx-border-width: 1; " +
                        "-fx-border-radius: 3; " +
                        "-fx-background-radius: 3; " +
                        "-fx-cursor: hand;"
                    ));
                    upButton.setOnAction(e -> movePhenotypeUp(getIndex()));

                    Button downButton = new Button("↓");
                    downButton.setStyle(
                        "-fx-font-size: 11px; " +
                        "-fx-padding: 2 4 2 4; " +
                        "-fx-min-width: 20px; " +
                        "-fx-min-height: 20px; " +
                        "-fx-background-color: #f8f8f8; " +
                        "-fx-text-fill: #333; " +
                        "-fx-border-color: #ccc; " +
                        "-fx-border-width: 1; " +
                        "-fx-border-radius: 3; " +
                        "-fx-background-radius: 3; " +
                        "-fx-cursor: hand;"
                    );
                    downButton.setOnMouseEntered(e -> downButton.setStyle(
                        "-fx-font-size: 11px; " +
                        "-fx-padding: 2 4 2 4; " +
                        "-fx-min-width: 20px; " +
                        "-fx-min-height: 20px; " +
                        "-fx-background-color: #e8e8e8; " +
                        "-fx-text-fill: #333; " +
                        "-fx-border-color: #999; " +
                        "-fx-border-width: 1; " +
                        "-fx-border-radius: 3; " +
                        "-fx-background-radius: 3; " +
                        "-fx-cursor: hand;"
                    ));
                    downButton.setOnMouseExited(e -> downButton.setStyle(
                        "-fx-font-size: 11px; " +
                        "-fx-padding: 2 4 2 4; " +
                        "-fx-min-width: 20px; " +
                        "-fx-min-height: 20px; " +
                        "-fx-background-color: #f8f8f8; " +
                        "-fx-text-fill: #333; " +
                        "-fx-border-color: #ccc; " +
                        "-fx-border-width: 1; " +
                        "-fx-border-radius: 3; " +
                        "-fx-background-radius: 3; " +
                        "-fx-cursor: hand;"
                    ));
                    downButton.setOnAction(e -> movePhenotypeDown(getIndex()));

                    // SEQUENTIAL 1/2/3 display instead of priority values
                    int sequenceNumber = getIndex() + 1; // 1-based sequence
                    Label priorityLabel = new Label(String.valueOf(sequenceNumber));
                    priorityLabel.setStyle("-fx-font-size: 11px; -fx-font-weight: bold; -fx-min-width: 16px; -fx-alignment: center;");

                    sortBox.getChildren().addAll(upButton, priorityLabel, downButton);
                    setGraphic(sortBox);
                }
            }
        });
        // 紧凑固定宽度设置 - 排序列固定70px，更紧凑
        sortCol.setPrefWidth(70);
        sortCol.setMinWidth(70);
        sortCol.setMaxWidth(70);

        // Name column - 智能宽度计算
        TableColumn<PhenotypeTableRow, String> nameCol = new TableColumn<>("分类名称");
        nameCol.setCellValueFactory(new PropertyValueFactory<>("name"));

        // 智能计算分类名称列宽度 - 根据最长名称动态调整
        double nameColumnWidth = calculateOptimalNameColumnWidth();
        nameCol.setPrefWidth(nameColumnWidth);
        nameCol.setMinWidth(Math.max(90, nameColumnWidth - 15)); // 减小最小宽度，更紧凑
        nameCol.setMaxWidth(nameColumnWidth + 20); // 减少扩展空间

        phenotypeTable.getColumns().add(sortCol);
        phenotypeTable.getColumns().add(nameCol);

        // 使用从阈值策略传递的通道，如果没有则使用全部通道
        List<String> channelsToUse = selectedChannelsFromThreshold.isEmpty() ?
                availableChannels.stream()
                    .filter(channel -> !channel.toLowerCase().contains("dapi"))
                    .collect(Collectors.toList()) :
                selectedChannelsFromThreshold;

        logger.info("创建表型表格 - 使用通道: {} (共{}个)", channelsToUse, channelsToUse.size());

        // Dynamic marker columns based on selected channels
        List<String> markerChannels = channelsToUse;
            
        for (String channel : markerChannels) {
            TableColumn<PhenotypeTableRow, String> markerCol = new TableColumn<>(channel);
            markerCol.setCellFactory(col -> new TableCell<PhenotypeTableRow, String>() {
                @Override
                protected void updateItem(String item, boolean empty) {
                    super.updateItem(item, empty);
                    if (empty || getTableRow() == null || getTableRow().getItem() == null) {
                        setGraphic(null);
                    } else {
                        ComboBox<String> comboBox = new ComboBox<>();
                        comboBox.getItems().addAll("阳性", "阴性", "无关");

                        // 简洁ComboBox样式
                        comboBox.setStyle(
                            "-fx-font-size: 12px; " +
                            "-fx-padding: 3 6 3 6; " +
                            "-fx-background-color: white; " +
                            "-fx-border-color: #ccc; " +
                            "-fx-border-width: 1; " +
                            "-fx-border-radius: 3; " +
                            "-fx-cursor: hand;"
                        );

                        double comboBoxWidth = calculateOptimalMarkerColumnWidth(markerChannels.size()) - 15; // 更紧凑
                        comboBox.setPrefWidth(comboBoxWidth);
                        comboBox.setMaxWidth(comboBoxWidth + 10); // 减少扩展空间

                        // 简化ComboBox悬停效果
                        comboBox.setOnMouseEntered(event -> {
                            comboBox.setStyle(
                                "-fx-font-size: 11px; " +
                                "-fx-padding: 3 6 3 6; " +
                                "-fx-background-color: #f8f8f8; " +
                                "-fx-border-color: #999; " +
                                "-fx-border-width: 1; " +
                                "-fx-border-radius: 3; " +
                                "-fx-cursor: hand;"
                            );
                        });
                        comboBox.setOnMouseExited(event -> {
                            comboBox.setStyle(
                                "-fx-font-size: 11px; " +
                                "-fx-padding: 3 6 3 6; " +
                                "-fx-background-color: white; " +
                                "-fx-border-color: #ccc; " +
                                "-fx-border-width: 1; " +
                                "-fx-border-radius: 3; " +
                                "-fx-cursor: hand;"
                            );
                        });

                        // Get current marker state from the phenotype
                        PhenotypeTableRow row = getTableRow().getItem();
                        String currentState = getCurrentMarkerState(row.getName(), channel);
                        comboBox.setValue(currentState != null ? currentState : "无关");

                        // 优化性能：减少不必要的表格刷新
                        comboBox.setOnAction(e -> {
                            PhenotypeTableRow currentRow = getTableView().getItems().get(getIndex());
                            String newValue = comboBox.getValue();
                            String oldValue = getCurrentMarkerState(currentRow.getName(), channel);

                            // 仅在值实际改变时更新
                            if (!Objects.equals(oldValue, newValue)) {
                                updatePhenotypeMarkerState(currentRow.getName(), channel, newValue);
                                logger.debug("Updated marker state for phenotype '{}', channel '{}': {} -> {}",
                                           currentRow.getName(), channel, oldValue, newValue);
                                // 移除自动表格刷新 - 让JavaFX的数据绑定自然处理
                            }
                        });

                        setGraphic(comboBox);
                    }
                }
            });

            // 智能列宽设置 - 根据通道数量和可用空间智能分配
            double markerColumnWidth = calculateOptimalMarkerColumnWidth(markerChannels.size());
            markerCol.setPrefWidth(markerColumnWidth);
            markerCol.setMinWidth(85); // 减小最小宽度，更紧凑
            markerCol.setMaxWidth(markerColumnWidth + 10); // 减少扩展空间

            // 设置列标题样式，调小字体大小
            markerCol.setStyle("-fx-font-size: 11px;");

            phenotypeTable.getColumns().add(markerCol);
        }

        // Action column - 优化宽度
        TableColumn<PhenotypeTableRow, Void> actionCol = new TableColumn<>("操作");
        actionCol.setCellFactory(col -> new TableCell<PhenotypeTableRow, Void>() {
            private final Button deleteButton = new Button("删除");

            {
                // 简洁删除按钮样式
                deleteButton.setStyle(
                    "-fx-font-size: 10px; " +
                    "-fx-padding: 3 6 3 6; " +
                    "-fx-min-width: 50px; " +
                    "-fx-pref-width: 60px; " +
                    "-fx-background-color: #f8f8f8; " +
                    "-fx-text-fill: #e53935; " +
                    "-fx-border-color: #e53935; " +
                    "-fx-border-width: 1; " +
                    "-fx-border-radius: 3; " +
                    "-fx-background-radius: 3; " +
                    "-fx-cursor: hand; " +
                    "-fx-font-weight: bold;"
                );

                // 简化悬停效果
                deleteButton.setOnMouseEntered(e -> deleteButton.setStyle(
                    "-fx-font-size: 10px; " +
                    "-fx-padding: 3 6 3 6; " +
                    "-fx-min-width: 50px; " +
                    "-fx-pref-width: 60px; " +
                    "-fx-background-color: #e53935; " +
                    "-fx-text-fill: white; " +
                    "-fx-border-color: #e53935; " +
                    "-fx-border-width: 1; " +
                    "-fx-border-radius: 3; " +
                    "-fx-background-radius: 3; " +
                    "-fx-cursor: hand; " +
                    "-fx-font-weight: bold;"
                ));

                deleteButton.setOnMouseExited(e -> deleteButton.setStyle(
                    "-fx-font-size: 10px; " +
                    "-fx-padding: 3 6 3 6; " +
                    "-fx-min-width: 50px; " +
                    "-fx-pref-width: 60px; " +
                    "-fx-background-color: #f8f8f8; " +
                    "-fx-text-fill: #e53935; " +
                    "-fx-border-color: #e53935; " +
                    "-fx-border-width: 1; " +
                    "-fx-border-radius: 3; " +
                    "-fx-background-radius: 3; " +
                    "-fx-cursor: hand; " +
                    "-fx-font-weight: bold;"
                ));

                deleteButton.setOnAction(e -> {
                    PhenotypeTableRow row = getTableView().getItems().get(getIndex());
                    phenotypeData.remove(row);
                    // Remove from phenotypes list
                    phenotypes.removeIf(p -> p.getName().equals(row.getName()));
                    refreshPriorities();
                    // 更新表格高度以适应删除后的细胞类型数量
                    updateTableHeight();
                });
            }

            @Override
            protected void updateItem(Void item, boolean empty) {
                super.updateItem(item, empty);
                if (empty) {
                    setGraphic(null);
                } else {
                    setGraphic(deleteButton);
                }
            }
        });
        // 紧凑固定宽度设置 - 操作列固定75px，更紧凑
        actionCol.setPrefWidth(75);
        actionCol.setMinWidth(75);
        actionCol.setMaxWidth(75);

        phenotypeTable.getColumns().add(actionCol);

        // 优化整体表格显示设置 - 支持30+通道滚动
        phenotypeTable.setPrefHeight(280); // 减小高度为其他内容留出空间
        phenotypeTable.setMaxHeight(350);

        // 强制表格支持水平滚动
        phenotypeTable.setColumnResizePolicy(TableView.UNCONSTRAINED_RESIZE_POLICY);

        // 记录紧凑优化成果
        double nameWidth = calculateOptimalNameColumnWidth();
        double markerWidth = calculateOptimalMarkerColumnWidth(markerChannels.size());
        logger.info("✅ 表型表格紧凑优化完成 (适配600px窗口):");
        logger.info("   📊 紧凑列宽度: 排序列70px | 分类名称列{}px | marker列{}px({}通道) | 操作列75px",
                   nameWidth, markerWidth, markerChannels.size());
        logger.info("   🎨 简洁设计: 统一灰色主题 | 简化边框 | 紧凑间距 | 清晰层次");
        logger.info("   📐 智能高度自适应: 2-3类型宽松 | 4-8类型标准 | 9+类型紧凑+滚动");
        logger.info("   ⚡ 性能优化: 减少刷新频率 | 异步UI更新 | 差异检测更新");
        logger.info("   🖱️  交互体验: 简洁悬停效果 | 紧凑控件尺寸 | 统一配色方案");
        logger.info("🚀 表型表格现已支持{}个通道的高效紧凑显示", markerChannels.size());
    }
    
    private void movePhenotypeUp(int index) {
        if (index > 0) {
            // ENHANCED: Move entire row positions instead of just swapping priorities
            PhenotypeTableRow current = phenotypeData.get(index);
            
            // Remove current row and insert it one position up
            phenotypeData.remove(index);
            phenotypeData.add(index - 1, current);
            
            // Also move the corresponding phenotype in the phenotypes list
            CellPhenotype currentPhenotype = null;
            int phenotypeIndex = -1;
            for (int i = 0; i < phenotypes.size(); i++) {
                if (phenotypes.get(i).getName().equals(current.getName())) {
                    currentPhenotype = phenotypes.get(i);
                    phenotypeIndex = i;
                    break;
                }
            }
            
            if (currentPhenotype != null && phenotypeIndex > 0) {
                phenotypes.remove(phenotypeIndex);
                phenotypes.add(phenotypeIndex - 1, currentPhenotype);
            }
            
            // Refresh priorities to maintain sequential 1,2,3... display
            refreshPriorities();

            // 优化：使用Platform.runLater避免阻塞UI线程，减少刷新频率
            Platform.runLater(() -> {
                // Select the moved row to maintain user focus
                phenotypeTable.getSelectionModel().select(index - 1);
                // 减少刷新：仅在数据实际变化时刷新
                phenotypeTable.refresh();
            });
        }
    }
    
    private void movePhenotypeDown(int index) {
        if (index < phenotypeData.size() - 1) {
            // ENHANCED: Move entire row positions instead of just swapping priorities
            PhenotypeTableRow current = phenotypeData.get(index);
            
            // Remove current row and insert it one position down
            phenotypeData.remove(index);
            phenotypeData.add(index + 1, current);
            
            // Also move the corresponding phenotype in the phenotypes list
            CellPhenotype currentPhenotype = null;
            int phenotypeIndex = -1;
            for (int i = 0; i < phenotypes.size(); i++) {
                if (phenotypes.get(i).getName().equals(current.getName())) {
                    currentPhenotype = phenotypes.get(i);
                    phenotypeIndex = i;
                    break;
                }
            }
            
            if (currentPhenotype != null && phenotypeIndex < phenotypes.size() - 1) {
                phenotypes.remove(phenotypeIndex);
                phenotypes.add(phenotypeIndex + 1, currentPhenotype);
            }
            
            // Refresh priorities to maintain sequential 1,2,3... display
            refreshPriorities();

            // 优化：使用Platform.runLater避免阻塞UI线程，减少刷新频率
            Platform.runLater(() -> {
                // Select the moved row to maintain user focus
                phenotypeTable.getSelectionModel().select(index + 1);
                // 减少刷新：仅在数据实际变化时刷新
                phenotypeTable.refresh();
            });
        }
    }
    
    private void updatePhenotypePriority(String phenotypeName, int newPriority) {
        for (int i = 0; i < phenotypes.size(); i++) {
            CellPhenotype phenotype = phenotypes.get(i);
            if (phenotype.getName().equals(phenotypeName)) {
                phenotypes.set(i, phenotype.withPriority(newPriority));
                break;
            }
        }
    }
    
    private void updatePhenotypeMarkerState(String phenotypeName, String channel, String state) {
        CellPhenotype.MarkerState markerState;
        switch (state) {
            case "阳性": markerState = CellPhenotype.MarkerState.POSITIVE; break;
            case "阴性": markerState = CellPhenotype.MarkerState.NEGATIVE; break;
            default: markerState = CellPhenotype.MarkerState.IGNORE; break;
        }
        
        for (int i = 0; i < phenotypes.size(); i++) {
            CellPhenotype phenotype = phenotypes.get(i);
            if (phenotype.getName().equals(phenotypeName)) {
                phenotypes.set(i, phenotype.withMarkerState(channel, markerState));
                break;
            }
        }
    }
    
    /**
     * Get current marker state for a phenotype and channel - UI synchronization support
     */
    private String getCurrentMarkerState(String phenotypeName, String channel) {
        for (CellPhenotype phenotype : phenotypes) {
            if (phenotype.getName().equals(phenotypeName)) {
                CellPhenotype.MarkerState markerState = phenotype.getMarkerState(channel);
                if (markerState != null) {
                    switch (markerState) {
                        case POSITIVE: return "阳性";
                        case NEGATIVE: return "阴性";
                        case IGNORE:
                        default: return "无关";
                    }
                }
            }
        }
        return "无关"; // Default state
    }
    
    private void refreshPriorities() {
        // ENHANCED: NULL-SAFE priority reassignment with proper row position mapping
        // Priorities are assigned in reverse order: first row gets highest priority
        for (int i = 0; i < phenotypeData.size(); i++) {
            PhenotypeTableRow row = phenotypeData.get(i);
            if (row != null && row.getName() != null) {
                // Higher priority for earlier rows (row 0 = highest priority)
                int newPriority = (phenotypeData.size() - i) * 10;
                phenotypeData.set(i, new PhenotypeTableRow(row.getName(), newPriority));
                updatePhenotypePriority(row.getName(), newPriority);
                
                logger.debug("Updated priority for phenotype '{}' at position {} to priority {}", 
                           row.getName(), i, newPriority);
            } else {
                logger.warn("NULL row or name detected at index {}, skipping priority update", i);
            }
        }
        
        // Ensure the phenotypes list is also ordered to match the table
        reorderPhenotypesList();
        
        phenotypeTable.refresh();
        logger.info("Refreshed priorities for {} phenotypes - display order: 1,2,3...", phenotypeData.size());
    }
    
    /**
     * Reorder the phenotypes list to match the table display order
     */
    private void reorderPhenotypesList() {
        List<CellPhenotype> reorderedPhenotypes = new ArrayList<>();
        
        // Build new ordered list based on table row order
        for (PhenotypeTableRow row : phenotypeData) {
            if (row != null && row.getName() != null) {
                for (CellPhenotype phenotype : phenotypes) {
                    if (phenotype.getName().equals(row.getName())) {
                        reorderedPhenotypes.add(phenotype);
                        break;
                    }
                }
            }
        }
        
        // Replace the phenotypes list with the reordered version
        if (reorderedPhenotypes.size() == phenotypes.size()) {
            phenotypes.clear();
            phenotypes.addAll(reorderedPhenotypes);
            logger.debug("Reordered phenotypes list to match table display order");
        } else {
            logger.warn("Phenotype list reordering failed: size mismatch ({} vs {})", 
                       reorderedPhenotypes.size(), phenotypes.size());
        }
    }
    
    private HBox createActionButtonsSection() {
        HBox buttonBox = new HBox(15); // 增加按钮间距
        buttonBox.setAlignment(Pos.CENTER); // 改为居中对齐
        buttonBox.setPadding(new Insets(15, 0, 0, 0));

        // 左侧配置管理按钮组
        HBox leftButtonGroup = new HBox(10);
        leftButtonGroup.setAlignment(Pos.CENTER_LEFT);

        // 保存配置按钮 - 保存到用户设置的保存地址
        Button saveConfigButton = new Button("保存配置");
        saveConfigButton.setStyle("-fx-background-color: #2196F3; -fx-text-fill: white; -fx-font-size: 13px;");
        saveConfigButton.setOnAction(e -> saveConfigurationToUserPath());

        // 加载配置按钮 - 改为蓝色，弹出文件选择框
        Button loadConfigButton = new Button("加载配置");
        loadConfigButton.setStyle("-fx-background-color: #2196F3; -fx-text-fill: white; -fx-font-size: 13px;");
        loadConfigButton.setOnAction(e -> loadConfigurationFromUserPath());

        leftButtonGroup.getChildren().addAll(saveConfigButton, loadConfigButton);

        // 右侧检测导出按钮组
        HBox rightButtonGroup = new HBox(10);
        rightButtonGroup.setAlignment(Pos.CENTER_RIGHT);

        Button runDetectionButton = new Button("运行检测并导出数据");
        runDetectionButton.setStyle("-fx-background-color: #4CAF50; -fx-text-fill: white; -fx-font-weight: bold; -fx-font-size: 13px;");
        runDetectionButton.setOnAction(e -> runDetectionWithExport());

        rightButtonGroup.getChildren().add(runDetectionButton);

        // 创建spacer使左右按钮组分离
        Region spacer = new Region();
        HBox.setHgrow(spacer, javafx.scene.layout.Priority.ALWAYS);

        buttonBox.getChildren().addAll(leftButtonGroup, spacer, rightButtonGroup);

        logger.info("按钮布局优化完成 - 配置管理功能增强，支持用户路径选择");
        return buttonBox;
    }
    
    private void performAutoThresholding() {
        if (strategyComboBox.getValue() == ThresholdConfig.Strategy.AUTO) {
            ImageData<?> imageData = qupath.getImageData();
            if (imageData != null) {
                // TODO: [集成] 使用新API重新实现自动阈值计算
                // CellPhenotypeAPI.calculateAutoThresholds(imageData, currentConfig);
                showAlert(Alert.AlertType.INFORMATION, "提示", "自动阈值计算功能将在下个版本重新实现");
            } else {
                showAlert(Alert.AlertType.WARNING, "Warning", "No image data available!");
            }
        }
    }
    
    private void addNewPhenotype() {
        // 优先使用阈值操作中选中的通道，没有则使用全部可用通道
        List<String> channelsToUse = selectedChannelsFromThreshold.isEmpty() ?
                availableChannels : selectedChannelsFromThreshold;

        logger.info("新增表型 - 使用通道列表: {} (来源: {})",
                channelsToUse,
                selectedChannelsFromThreshold.isEmpty() ? "全部可用通道" : "阈值策略选中通道");

        PhenotypeEditorDialog dialog = new PhenotypeEditorDialog(stage, channelsToUse);
        dialog.showAndWait().ifPresent(phenotype -> {
            phenotypes.add(phenotype);

            // Add to table with auto-assigned priority
            int priority = (phenotypeData.size() + 1) * 10;
            PhenotypeTableRow row = new PhenotypeTableRow(phenotype.getName(), priority);
            phenotypeData.add(row);

            // Update the phenotype with the assigned priority
            phenotypes.set(phenotypes.size() - 1, phenotype.withPriority(priority));

            // Force table refresh to ensure correct display
            Platform.runLater(() -> {
                phenotypeTable.refresh();
            });

            // 更新表格高度以适应新增的细胞类型
            updateTableHeight();
        });
    }

    /**
     * 智能计算分类名称列的最优宽度 - 紧凑版本适配600px窗口
     */
    private double calculateOptimalNameColumnWidth() {
        double baseWidth = 100; // 减小基础宽度，更紧凑
        double maxWidth = 160;  // 减小最大宽度限制

        if (phenotypes.isEmpty()) {
            return baseWidth;
        }

        // 计算最长名称的近似像素宽度
        int maxNameLength = phenotypes.stream()
            .mapToInt(p -> p.getName().length())
            .max()
            .orElse(8);

        // 紧凑计算：根据字符长度估算像素宽度 (中文字符约10px，英文字符约7px)
        double estimatedWidth = Math.max(baseWidth, maxNameLength * 8 + 30); // 减少边距

        // 限制在紧凑范围内
        return Math.min(estimatedWidth, maxWidth);
    }

    /**
     * 智能计算marker列的最优宽度 - 紧凑版本适配600px窗口
     */
    private double calculateOptimalMarkerColumnWidth(int channelCount) {
        double minWidth = 85;   // 减小最小宽度，更紧凑
        double maxWidth = 105;  // 减小最大宽度

        if (channelCount <= 4) {
            return maxWidth; // 通道少时使用较大宽度
        } else if (channelCount <= 10) {
            return 95; // 中等通道数使用标准宽度
        } else {
            return minWidth; // 通道多时使用紧凑宽度
        }
    }

    /**
     * 智能更新表格高度以适应细胞类型数量 - 现代化自适应机制
     */
    private void updateTableHeight() {
        Platform.runLater(() -> {
            try {
                int cellTypeCount = Math.max(phenotypes.size(), 2); // 最少显示2行，更紧凑

                // 智能行高计算 - 根据内容密度动态调整
                double baseRowHeight = 45; // 基础行高增加以适应新样式
                double headerHeight = 50;  // 表头高度
                double paddingHeight = 20; // 上下边距

                // 根据细胞类型数量调整策略
                double adaptiveHeight;
                if (cellTypeCount <= 3) {
                    // 少量类型时使用较大行高，提供更好的可读性
                    adaptiveHeight = cellTypeCount * (baseRowHeight + 5) + headerHeight + paddingHeight;
                } else if (cellTypeCount <= 8) {
                    // 中等数量时使用标准行高
                    adaptiveHeight = cellTypeCount * baseRowHeight + headerHeight + paddingHeight;
                } else {
                    // 大量类型时使用紧凑行高，设置合理的最大高度
                    double compactHeight = cellTypeCount * (baseRowHeight - 5) + headerHeight + paddingHeight;
                    adaptiveHeight = Math.min(compactHeight, 400); // 最大高度400px，超过则显示滚动条
                }

                // 查找现有的ScrollPane并更新高度
                javafx.scene.Node parentNode = phenotypeTable.getParent();
                if (parentNode instanceof ScrollPane) {
                    ScrollPane scrollPane = (ScrollPane) parentNode;
                    scrollPane.setPrefHeight(adaptiveHeight);

                    // 智能最大高度设置
                    if (cellTypeCount > 8) {
                        scrollPane.setMaxHeight(400); // 大量类型时限制高度
                        scrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);
                        logger.debug("表格启用垂直滚动模式 - 类型数: {}, 高度: {}", cellTypeCount, adaptiveHeight);
                    } else {
                        scrollPane.setMaxHeight(adaptiveHeight + 10);
                        scrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
                        logger.debug("表格高度完全自适应 - 类型数: {}, 高度: {}", cellTypeCount, adaptiveHeight);
                    }

                    logger.info("智能表格高度已更新: {}px (细胞类型数: {}, 策略: {})",
                               adaptiveHeight, cellTypeCount,
                               cellTypeCount <= 3 ? "宽松" : cellTypeCount <= 8 ? "标准" : "紧凑");
                }
            } catch (Exception e) {
                logger.warn("更新表格高度失败: {}", e.getMessage());
            }
        });
    }


    /**
     * 保存配置到用户指定的保存地址
     */
    private void saveConfigurationToUserPath() {
        updateCurrentConfiguration();

        // 获取用户设置的保存地址
        String savePath = savePathField.getText();
        if (savePath == null || savePath.trim().isEmpty()) {
            showAlert(Alert.AlertType.WARNING, "警告", "请在基础设置中设置保存地址！");
            return;
        }

        java.io.File saveDir = new java.io.File(savePath.trim());
        if (!saveDir.exists()) {
            showAlert(Alert.AlertType.WARNING, "警告", "保存地址不存在：" + savePath);
            return;
        }

        try {
            // 创建配置数据
            Map<String, Object> configData = new HashMap<>();
            configData.put("config", currentConfig);
            configData.put("phenotypes", phenotypes);
            configData.put("channelMapping", channelNameMapping);
            configData.put("availableChannels", availableChannels);
            configData.put("selectedChannels", selectedChannelsFromThreshold);

            // 生成配置文件名（包含配置名称和时间戳）
            String configName = configNameField.getText().trim();
            if (configName.isEmpty()) {
                configName = "Default";
            }
            // 清理配置名称，移除不安全的文件名字符
            String safeConfigName = configName.replaceAll("[\\\\/:*?\"<>|]", "_");
            String timeStamp = new java.text.SimpleDateFormat("yyyyMMdd_HHmmss").format(new java.util.Date());
            String fileName = safeConfigName + "_" + timeStamp + ".json";
            java.io.File configFile = new java.io.File(saveDir, fileName);

            // 保存为JSON文件
            ObjectMapper mapper = new ObjectMapper();
            String configJson = mapper.writeValueAsString(configData);

            try (java.io.FileWriter writer = new java.io.FileWriter(configFile)) {
                writer.write(configJson);
            }

            showAlert(Alert.AlertType.INFORMATION, "保存成功",
                String.format("配置已保存到：\\n%s\\n\\n包含内容：\\n- 阈值配置：%d个通道\\n- 表型定义：%d个\\n- 通道映射：%d个",
                    configFile.getAbsolutePath(),
                    currentConfig.getChannelThresholds().size(),
                    phenotypes.size(),
                    channelNameMapping.size()));

            logger.info("配置保存成功: {}", configFile.getAbsolutePath());
        } catch (Exception e) {
            logger.error("配置保存失败: {}", e.getMessage(), e);
            showAlert(Alert.AlertType.ERROR, "保存失败", "配置保存失败: " + e.getMessage());
        }
    }

    /**
     * 从用户选择的文件加载配置
     */
    private void loadConfigurationFromUserPath() {
        try {
            // 创建文件选择器
            javafx.stage.FileChooser fileChooser = new javafx.stage.FileChooser();
            fileChooser.setTitle("选择配置文件");

            // 设置文件过滤器
            javafx.stage.FileChooser.ExtensionFilter jsonFilter =
                new javafx.stage.FileChooser.ExtensionFilter("配置文件 (*.json)", "*.json");
            fileChooser.getExtensionFilters().add(jsonFilter);

            // 设置初始目录为保存地址
            String savePath = savePathField.getText();
            if (savePath != null && !savePath.trim().isEmpty()) {
                java.io.File saveDir = new java.io.File(savePath.trim());
                if (saveDir.exists() && saveDir.isDirectory()) {
                    fileChooser.setInitialDirectory(saveDir);
                }
            }

            // 显示文件选择对话框
            java.io.File selectedFile = fileChooser.showOpenDialog(stage);
            if (selectedFile == null) {
                return; // 用户取消选择
            }

            if (!selectedFile.exists()) {
                showAlert(Alert.AlertType.ERROR, "文件不存在", "选择的配置文件不存在：" + selectedFile.getName());
                return;
            }

            // 读取和解析配置文件
            ObjectMapper mapper = new ObjectMapper();
            String configJson = new String(java.nio.file.Files.readAllBytes(selectedFile.toPath()));

            // 基础JSON解析验证
            Map<String, Object> configData = mapper.readValue(configJson, Map.class);

            // 验证配置文件内容
            if (!configData.containsKey("config") || !configData.containsKey("phenotypes")) {
                showAlert(Alert.AlertType.ERROR, "配置文件错误", "配置文件格式不正确，缺少必要的配置数据");
                return;
            }

            // 显示加载成功信息
            int configCount = configData.containsKey("config") ? 1 : 0;
            int phenotypeCount = 0;
            int channelCount = 0;

            if (configData.get("phenotypes") instanceof java.util.List) {
                phenotypeCount = ((java.util.List<?>) configData.get("phenotypes")).size();
            }

            if (configData.get("availableChannels") instanceof java.util.List) {
                channelCount = ((java.util.List<?>) configData.get("availableChannels")).size();
            }

            // 开始应用配置数据到所有设置
            try {
                boolean configApplied = false;

                // 1. 应用阈值配置
                if (configData.containsKey("config")) {
                    Map<String, Object> configMap = (Map<String, Object>) configData.get("config");
                    if (configMap != null) {
                        // 应用配置名称
                        if (configMap.containsKey("configName") && configNameField != null) {
                            configNameField.setText(String.valueOf(configMap.get("configName")));
                        }

                        // 应用策略选择
                        if (configMap.containsKey("strategy") && strategyComboBox != null) {
                            String strategyName = String.valueOf(configMap.get("strategy"));
                            for (ThresholdConfig.Strategy strategy : ThresholdConfig.Strategy.values()) {
                                if (strategy.toString().equals(strategyName)) {
                                    strategyComboBox.setValue(strategy);
                                    break;
                                }
                            }
                        }

                        // 应用通道阈值配置
                        if (configMap.containsKey("channelThresholds")) {
                            Map<String, Object> thresholds = (Map<String, Object>) configMap.get("channelThresholds");
                            if (thresholds != null) {
                                for (Map.Entry<String, Object> entry : thresholds.entrySet()) {
                                    String channelName = entry.getKey();
                                    Map<String, Object> thresholdData = (Map<String, Object>) entry.getValue();

                                    if (thresholdData != null && availableChannels.contains(channelName)) {
                                        // 应用measurement类型
                                        if (thresholdData.containsKey("measurement")) {
                                            ComboBox<String> measurementCombo = measurementComboBoxes.get(channelName);
                                            if (measurementCombo != null) {
                                                measurementCombo.setValue(String.valueOf(thresholdData.get("measurement")));
                                            }
                                        }

                                        // 应用阈值
                                        if (thresholdData.containsKey("threshold")) {
                                            double threshold = Double.parseDouble(String.valueOf(thresholdData.get("threshold")));
                                            updateThresholdDisplay(channelName, threshold);

                                            // 更新内部配置
                                            String measurement = String.valueOf(thresholdData.getOrDefault("measurement", "Nucleus: Mean"));
                                            boolean enabled = Boolean.parseBoolean(String.valueOf(thresholdData.getOrDefault("enabled", true)));
                                            ThresholdConfig.ChannelThreshold channelThreshold =
                                                new ThresholdConfig.ChannelThreshold(measurement, threshold, enabled);
                                            currentConfig = currentConfig.withChannelThreshold(channelName, channelThreshold);
                                        }
                                    }
                                }
                            }
                        }
                        configApplied = true;
                    }
                }

                // 2. 应用表型定义
                if (configData.containsKey("phenotypes")) {
                    List<Object> phenotypeList = (List<Object>) configData.get("phenotypes");
                    if (phenotypeList != null && !phenotypeList.isEmpty()) {
                        // 清空现有表型
                        phenotypes.clear();
                        phenotypeData.clear();

                        // 加载表型数据
                        for (Object phenotypeObj : phenotypeList) {
                            Map<String, Object> phenotypeMap = (Map<String, Object>) phenotypeObj;
                            if (phenotypeMap != null && phenotypeMap.containsKey("name")) {
                                String phenotypeName = String.valueOf(phenotypeMap.get("name"));
                                int priority = Integer.parseInt(String.valueOf(phenotypeMap.getOrDefault("priority", 10)));

                                // 创建表型对象 - 使用正确的构造器
                                CellPhenotype phenotype = new CellPhenotype(phenotypeName, priority);

                                // 应用marker状态（如果存在）
                                if (phenotypeMap.containsKey("markerStates")) {
                                    Map<String, Object> markerStates = (Map<String, Object>) phenotypeMap.get("markerStates");
                                    if (markerStates != null) {
                                        for (Map.Entry<String, Object> markerEntry : markerStates.entrySet()) {
                                            String channel = markerEntry.getKey();
                                            String stateStr = String.valueOf(markerEntry.getValue());

                                            CellPhenotype.MarkerState markerState = CellPhenotype.MarkerState.IGNORE;
                                            if ("POSITIVE".equals(stateStr)) {
                                                markerState = CellPhenotype.MarkerState.POSITIVE;
                                            } else if ("NEGATIVE".equals(stateStr)) {
                                                markerState = CellPhenotype.MarkerState.NEGATIVE;
                                            } else if ("IGNORE".equals(stateStr)) {
                                                markerState = CellPhenotype.MarkerState.IGNORE;
                                            }

                                            phenotype = phenotype.withMarkerState(channel, markerState);
                                        }
                                    }
                                }

                                phenotypes.add(phenotype);
                                phenotypeData.add(new PhenotypeTableRow(phenotypeName, priority));
                            }
                        }

                        // 刷新表型表格显示
                        if (phenotypeTable != null) {
                            phenotypeTable.refresh();
                        }
                        configApplied = true;
                    }
                }

                // 3. 应用通道映射（如果存在）
                if (configData.containsKey("channelMapping")) {
                    Map<String, Object> channelMapping = (Map<String, Object>) configData.get("channelMapping");
                    if (channelMapping != null) {
                        channelNameMapping.clear();
                        for (Map.Entry<String, Object> entry : channelMapping.entrySet()) {
                            channelNameMapping.put(entry.getKey(), String.valueOf(entry.getValue()));
                        }
                        configApplied = true;
                    }
                }

                // 4. 应用可用通道列表（如果存在）
                if (configData.containsKey("availableChannels")) {
                    List<Object> channels = (List<Object>) configData.get("availableChannels");
                    if (channels != null) {
                        availableChannels.clear();
                        for (Object channel : channels) {
                            availableChannels.add(String.valueOf(channel));
                        }
                        configApplied = true;
                    }
                }

                // 5. 应用选中通道列表（如果存在）
                if (configData.containsKey("selectedChannels")) {
                    List<Object> selectedChannels = (List<Object>) configData.get("selectedChannels");
                    if (selectedChannels != null) {
                        selectedChannelsFromThreshold.clear();
                        for (Object channel : selectedChannels) {
                            selectedChannelsFromThreshold.add(String.valueOf(channel));
                        }
                        configApplied = true;
                    }
                }

                // 刷新界面以反映加载的配置
                if (configApplied) {
                    // 重新创建通道控件以应用新配置
                    createChannelControls();

                    // 更新所有通道的状态显示和选择状态
                    for (String channelName : availableChannels) {
                        // 检查配置数据中是否有该通道的阈值设置
                        boolean hasThresholdInConfig = currentConfig.getChannelThresholds().containsKey(channelName);

                        // 更新阈值状态标签
                        updateThresholdStatus(channelName, hasThresholdInConfig);

                        // 更新选择状态
                        updateChannelSelectionStatus(channelName);
                    }

                    // 重新创建表型表格以应用新数据
                    createPhenotypeTable();

                    logger.info("配置应用完成: 阈值配置、表型定义、通道映射、状态显示已全部恢复");
                }

                showAlert(Alert.AlertType.INFORMATION, "配置加载成功",
                    String.format("配置文件加载并应用成功：\\n%s\\n\\n已恢复内容：\\n- 阈值配置：%d个通道\\n- 表型定义：%d个\\n- 通道映射：%d个\\n- 选中通道：%d个\\n\\n所有设置已更新完成！",
                        selectedFile.getName(),
                        currentConfig.getChannelThresholds().size(),
                        phenotypes.size(),
                        channelNameMapping.size(),
                        selectedChannelsFromThreshold.size()));

            } catch (Exception applyEx) {
                logger.error("配置应用失败: {}", applyEx.getMessage(), applyEx);
                showAlert(Alert.AlertType.WARNING, "配置应用警告",
                    "配置文件读取成功，但部分设置应用失败: " + applyEx.getMessage());
            }

            logger.info("配置文件加载成功: {} (表型数: {}, 通道数: {})",
                       selectedFile.getAbsolutePath(), phenotypeCount, channelCount);

        } catch (Exception e) {
            logger.error("配置加载失败: {}", e.getMessage(), e);
            showAlert(Alert.AlertType.ERROR, "加载失败", "配置文件加载失败: " + e.getMessage());
        }
    }

    /**
     * Legacy method - kept for compatibility
     */
    private void saveConfigurationToProject() {
        updateCurrentConfiguration();
        
        Project<?> project = qupath.getProject();
        if (project == null) {
            showAlert(Alert.AlertType.WARNING, "Warning", "No project is currently open!");
            return;
        }
        
        try {
            // Save configuration to a project file instead
            Map<String, Object> configData = new HashMap<>();
            configData.put("config", currentConfig);
            configData.put("phenotypes", phenotypes);
            
            // Save to project directory as a JSON file
            ObjectMapper mapper = new ObjectMapper();
            String configJson = mapper.writeValueAsString(configData);
            
            java.io.File projectDir = project.getPath().getParent().toFile();
            java.io.File configFile = new java.io.File(projectDir, "cell_phenotype_config.json");
            
            try (java.io.FileWriter writer = new java.io.FileWriter(configFile)) {
                writer.write(configJson);
            }
            
            showAlert(Alert.AlertType.INFORMATION, "Success", 
                "Configuration saved to project directory: " + configFile.getName());
        } catch (Exception e) {
            showAlert(Alert.AlertType.ERROR, "Error", "Failed to save configuration: " + e.getMessage());
        }
    }
    
    private void loadConfigurationFromProject() {
        Project<?> project = qupath.getProject();
        if (project == null) {
            showAlert(Alert.AlertType.WARNING, "Warning", "No project is currently open!");
            return;
        }
        
        try {
            // Load from project directory JSON file
            java.io.File projectDir = project.getPath().getParent().toFile();
            java.io.File configFile = new java.io.File(projectDir, "cell_phenotype_config.json");
            
            if (configFile.exists()) {
                // Read and parse configuration
                ObjectMapper mapper = new ObjectMapper();
                String configJson = new String(java.nio.file.Files.readAllBytes(configFile.toPath()));
                
                // Load and apply configuration
                // This is a simplified version - in reality you'd need proper deserialization
                showAlert(Alert.AlertType.INFORMATION, "Success", 
                    "Configuration loaded from project directory: " + configFile.getName());
            } else {
                showAlert(Alert.AlertType.INFORMATION, "Information", 
                    "No saved configuration found in project directory.");
            }
        } catch (Exception e) {
            showAlert(Alert.AlertType.ERROR, "Error", "Failed to load configuration: " + e.getMessage());
        }
    }
    
    /**
     * Enhanced run detection with comprehensive data export including:
     * - Cell ID, Position (x,y), Parent, Classification, CellType
     * - CSV format output with complete cell information
     * - Immediate pseudo-coloring application
     */
    private void runDetectionWithExport() {
        ImageData<?> imageData = qupath.getImageData();
        if (imageData == null) {
            showAlert(Alert.AlertType.WARNING, "Warning", "No image data available!");
            return;
        }
        
        // Use save path from basic settings instead of prompting user
        String savePath = savePathField.getText();
        if (savePath == null || savePath.trim().isEmpty()) {
            showAlert(Alert.AlertType.WARNING, "警告", "请在基础设置中设置保存地址！");
            return;
        }
        
        java.io.File saveDir = new java.io.File(savePath.trim());
        if (!saveDir.exists()) {
            showAlert(Alert.AlertType.WARNING, "警告", "保存地址不存在：" + savePath);
            return;
        }
        
        // Create save file in the configured directory with image and ROI names
        String imageName = "Unknown";
        String roiName = "";

        // Get image name from ImageData
        if (imageData.getServer() != null && imageData.getServer().getMetadata() != null) {
            String fullImageName = imageData.getServer().getMetadata().getName();
            if (fullImageName != null && !fullImageName.isEmpty()) {
                // Extract base name without extension
                imageName = fullImageName.replaceFirst("\\.[^.]+$", "");
            }
        }

        // Get ROI name if ROI mode is enabled and ROI is selected
        boolean isRoiModeEnabled = cellAnalysisComboBox != null && "当前选中细胞".equals(cellAnalysisComboBox.getValue());
        if (isRoiModeEnabled) {
            var selectedROI = imageData.getHierarchy().getSelectionModel().getSelectedObject();
            if (selectedROI != null && selectedROI.getName() != null && !selectedROI.getName().isEmpty()) {
                roiName = selectedROI.getName();
            } else {
                roiName = "ROI";  // Default ROI name if no specific name is set
            }
        }

        // Clean names for safe file naming
        String safeImageName = imageName.replaceAll("[\\\\/:*?\"<>|]", "_");
        String safeRoiName = roiName.replaceAll("[\\\\/:*?\"<>|]", "_");
        String timeStamp = new java.text.SimpleDateFormat("yyyyMMdd_HHmmss").format(new java.util.Date());

        // Build filename with ROI name if available
        String fileName;
        if (!roiName.isEmpty()) {
            fileName = safeImageName + "_" + safeRoiName + "-classification_and_celltype-" + timeStamp + ".csv";
        } else {
            fileName = safeImageName + "-classification_and_celltype-" + timeStamp + ".csv";
        }
        java.io.File saveFile = new java.io.File(saveDir, fileName);
        
        updateCurrentConfiguration();
        
        try {
            // Create PhenotypeManager from phenotypes list
            PhenotypeManager phenotypeManager = new PhenotypeManager();
            for (CellPhenotype phenotype : phenotypes) {
                phenotypeManager.addPhenotype(phenotype);
            }
            
            logger.info("Starting comprehensive detection with data export...");
            long startTime = System.currentTimeMillis();
            
            // Use ROI-filtered cells if ROI mode is enabled
            List<qupath.lib.objects.PathObject> cellsToProcess = getCellsInSelectedROI(imageData);
            
            // Apply cell classification with pseudo-coloring and channel mapping
            CellPhenotypeAPI.applyCellClassification(imageData, currentConfig, phenotypeManager);

            // Apply gray-white pseudo color to unclassified cells
            applyGrayColorToUnclassifiedCells(imageData);

            // ENHANCED: Comprehensive display update for pseudo-coloring
            var hierarchy = imageData.getHierarchy();
            hierarchy.fireHierarchyChangedEvent(null);
            syncQuPathDisplayData(imageData);
            
            // CRITICAL: Final display update to ensure pseudo-colors are visible
            Platform.runLater(() -> {
                updateViewerForAllZoomLevels();
                logger.info("Final pseudo-color display update completed");
            });
            
            // ENHANCED: Export comprehensive cell data
            exportComprehensiveCellData(imageData, cellsToProcess, saveFile);

            // CRITICAL: Force final project save to ensure maximum color persistence
            try {
                logger.info("Executing final project save for maximum color persistence...");

                // Force mark as changed and trigger save
                imageData.setChanged(true);

                // Try to manually trigger QuPath's save mechanism
                Platform.runLater(() -> {
                    try {
                        // Force mark as changed to trigger save mechanisms
                        imageData.setChanged(true);

                        // Trigger repaint to ensure changes are visible
                        Platform.runLater(() -> {
                            if (qupath.getViewer() != null) {
                                qupath.getViewer().repaint();
                            }
                        });
                        logger.debug("Triggered QuPath repaint for project save");
                    } catch (Exception e) {
                        logger.debug("Could not trigger GUI refresh: {}", e.getMessage());
                    }
                });

                logger.info("Final project save mechanism triggered successfully");
            } catch (Exception e) {
                logger.warn("Final project save failed: {}", e.getMessage());
            }
            
            long duration = System.currentTimeMillis() - startTime;
            logger.info("Comprehensive detection and export completed in {}ms", duration);
            
            // Count classified cells for feedback
            int totalCells = cellsToProcess.size();
            long classifiedCells = cellsToProcess.stream()
                .mapToLong(cell -> cell.getPathClass() != null ? 1 : 0)
                .sum();
            
            showAlert(Alert.AlertType.INFORMATION, "检测和导出完成",
                String.format("综合检测完成! 用时 %dms\n" +
                             "总细胞: %d\n" +
                             "分类细胞: %d\n" +
                             "数据已导出到:\n%s\n\n" +
                             "✅ 伪彩效果已永久保存到QuPath项目中\n" +
                             "✅ 分类结果已持久化，关闭插件后依然有效\n" +
                             "✅ 细胞颜色和分类信息将随项目一起保存",
                    duration, totalCells, classifiedCells, saveFile.getAbsolutePath()));
                    
        } catch (Exception e) {
            logger.error("Detection and export failed: {}", e.getMessage(), e);
            showAlert(Alert.AlertType.ERROR, "Error", "Detection and export failed: " + e.getMessage());
        }
    }
    
    /**
     * Export comprehensive cell data including:
     * Cell_ID, X, Y, Parent, Classification, CellType
     */
    private void exportComprehensiveCellData(ImageData<?> imageData, 
                                           List<qupath.lib.objects.PathObject> cells, 
                                           java.io.File saveFile) throws IOException {
        
        logger.info("Exporting comprehensive cell data for {} cells to {}", cells.size(), saveFile.getName());
        
        try (java.io.FileWriter writer = new java.io.FileWriter(saveFile)) {
            // Write comprehensive header
            writer.write("Cell_ID,X,Y,Parent,Classification,CellType\n");
            
            // Process each cell and export complete information
            int exportedCount = 0;
            for (qupath.lib.objects.PathObject cell : cells) {
                try {
                    // Get cell basic information
                    String cellId = cell.getID() != null ? cell.getID().toString() : "cell_" + exportedCount;
                    
                    // Get centroid coordinates
                    double x = 0, y = 0;
                    if (cell.getROI() != null) {
                        x = cell.getROI().getCentroidX();
                        y = cell.getROI().getCentroidY();
                    }
                    
                    // Get parent information
                    String parentId = "";
                    if (cell.getParent() != null && cell.getParent().getID() != null) {
                        parentId = cell.getParent().getID().toString();
                    }
                    
                    // ENHANCED: Get BOTH Classification and CellType data separately

                    // 1. Get Classification from Load Object Classifier (stored in our mapping)
                    String classification = getClassificationName(cellId);
                    if (classification.isEmpty()) {
                        classification = ""; // No Load Object Classifier result
                    }

                    // 2. Get CellType from Cell Classification (check measurements for CellType_Info)
                    String cellType = "";
                    var measurements = cell.getMeasurementList();
                    if (measurements.containsKey("CellType_Info")) {
                        double cellTypeHash = measurements.get("CellType_Info");
                        if (cellTypeHash != 0.0) {
                            // Try to reconstruct CellType from current configuration
                            cellType = generateCellTypeFromMeasurements(cell);
                        }
                    }

                    // 3. Get CellType from PathClass - this is the authoritative source
                    if (cellType.isEmpty() && cell.getPathClass() != null) {
                        String pathClassName = cell.getPathClass().getName();

                        // The PathClass name IS the CellType - it contains either:
                        // 1. A defined phenotype name (e.g., "Helper T Cell", "B Cell")
                        // 2. "undefined" for unclassified cells
                        cellType = pathClassName;

                        // Classification should be derived from marker states, not PathClass
                        // If we don't have a separate classification, generate it from markers
                        if (classification.isEmpty()) {
                            classification = generateClassificationFromMarkers(cell);
                        }
                    }

                    // 4. Final fallback: if no CellType found, it should be "undefined"
                    if (cellType.isEmpty()) {
                        cellType = "undefined";
                    }
                    
                    // Write row data
                    writer.write(String.format("%s,%.2f,%.2f,%s,%s,%s\n",
                        cellId, x, y, parentId, classification, cellType));
                    
                    exportedCount++;
                    
                    // Log progress for large datasets
                    if (exportedCount % 10000 == 0) {
                        logger.info("Exported {} cells...", exportedCount);
                    }
                    
                } catch (Exception e) {
                    logger.debug("Error exporting cell {}: {}", cell.getID(), e.getMessage());
                }
            }
            
            logger.info("Successfully exported {} cells to {}", exportedCount, saveFile.getName());
        }
    }
    
    /**
     * Generate CellType string from cell measurements and current thresholds
     */
    private String generateCellTypeFromClassification(qupath.lib.objects.PathObject cell, String classification) {
        try {
            var measurements = cell.getMeasurementList();
            StringBuilder cellTypeBuilder = new StringBuilder();
            
            // Generate CellType from available measurements and current thresholds
            for (String channelName : availableChannels) {
                // Try to find measurement for this channel
                String[] possibleMeasurementNames = createPossibleMeasurementNames(channelName, "Nucleus: Mean");
                String actualMeasurementName = null;
                
                for (String testName : possibleMeasurementNames) {
                    if (measurements.containsKey(testName)) {
                        actualMeasurementName = testName;
                        break;
                    }
                }
                
                if (actualMeasurementName != null) {
                    double value = measurements.get(actualMeasurementName);
                    ThresholdConfig.ChannelThreshold threshold = currentConfig.getChannelThresholds().get(channelName);
                    
                    if (threshold != null) {
                        boolean isPositive = value > threshold.getThreshold();
                        String marker = channelName + (isPositive ? "+" : "-");
                        
                        if (cellTypeBuilder.length() > 0) {
                            cellTypeBuilder.append("");
                        }
                        cellTypeBuilder.append(marker);
                    }
                }
            }
            
            return cellTypeBuilder.toString();
            
        } catch (Exception e) {
            logger.debug("Error generating CellType for cell {}: {}", cell.getID(), e.getMessage());
            return classification; // Fallback to classification name
        }
    }
    
    // LEGACY: Keep old export method for compatibility
    private void exportEnhancedResults(List<CellPhenotypeClassifier.ClassificationResult> results, String filePath) throws IOException {
        try (java.io.FileWriter writer = new java.io.FileWriter(filePath)) {
            // Write header with new fields
            writer.write("Cell_ID,X,Y,Parent,Class,CellType\n");
            
            // Write data
            for (CellPhenotypeClassifier.ClassificationResult result : results) {
                // Get additional information
                ImageData<?> imageData = qupath.getImageData();
                if (imageData != null) {
                    var hierarchy = imageData.getHierarchy();
                    var cells = new ArrayList<>(hierarchy.getDetectionObjects());
                    
                    for (var cell : cells) {
                        if (cell.getID().toString().equals(result.getCellId())) {
                            String parentId = cell.getParent() != null ? cell.getParent().getID().toString() : "";
                            String pathClassName = cell.getPathClass() != null ? cell.getPathClass().getName() : "";
                            
                            // Class contains individual marker states (positive/negative)
                            String classStates = generateClassString(cell, result.getPositiveProteins());
                            
                            writer.write(String.format("%s,%.2f,%.2f,%s,%s,%s\n",
                                result.getCellId(),
                                result.getCentroidX(),
                                result.getCentroidY(),
                                parentId,
                                classStates,
                                result.getPhenotypeName()
                            ));
                            break;
                        }
                    }
                }
            }
        }
    }
    
    private String generateClassString(Object cell, String positiveProteins) {
        // Generate class string showing positive/negative states for each enabled channel
        // Format: CD3+_CD4+_CD8- (traditional QuPath classification format)
        StringBuilder classBuilder = new StringBuilder();
        Set<String> positiveSet = new HashSet<>();

        if (positiveProteins != null && !positiveProteins.trim().isEmpty()) {
            positiveSet.addAll(Arrays.asList(positiveProteins.split(",")));
        }

        List<String> stateList = new ArrayList<>();

        // Only include enabled channels in the classification string
        for (String channel : availableChannels) {
            // Check if this channel is enabled in current threshold config
            if (currentConfig != null &&
                currentConfig.getChannelThresholds().containsKey(channel) &&
                currentConfig.getChannelThresholds().get(channel).isEnabled()) {

                boolean isPositive = positiveSet.contains(channel.trim());
                stateList.add(channel + (isPositive ? "+" : "-"));
            }
        }

        if (stateList.isEmpty()) {
            return "undefined";
        }

        return String.join("_", stateList);
    }
    
    private void updateCurrentConfiguration() {
        // Update basic settings
        currentConfig = currentConfig
            .withConfigName(configNameField.getText())
            .withStrategy(strategyComboBox.getValue());
        
        // Update thresholds from dynamic controls
        for (String channel : availableChannels) {
            Slider slider = thresholdSliders.get(channel);
            ComboBox<String> measurementBox = measurementComboBoxes.get(channel);
            
            if (slider != null && measurementBox != null) {
                ThresholdConfig.ChannelThreshold threshold = new ThresholdConfig.ChannelThreshold(
                    measurementBox.getValue(),
                    getLinearValue(slider),  // Convert from log scale
                    true // For now, assume all channels are enabled
                );
                currentConfig = currentConfig.withChannelThreshold(channel, threshold);
            }
        }
    }
    
    private void showAlert(Alert.AlertType type, String title, String message) {
        Alert alert = new Alert(type);
        alert.setTitle(title);
        alert.setHeaderText(null);
        alert.setContentText(message);
        alert.showAndWait();
    }
    
    /**
     * Toggle between Create Single Measurement Classifier and Load Classifier operation modes
     */
    private void toggleOperationMode() {
        // Clear any existing preview when switching modes
        clearLivePreview();

        currentMode = (currentMode == OperationMode.CREATE_CLASSIFIER) ? OperationMode.LOAD_CLASSIFIER : OperationMode.CREATE_CLASSIFIER;

        // Update combo box value
        if (modeComboBox != null) {
            modeComboBox.setValue(currentMode);
        }

        // Update button states
        updateButtonStates();

        // Force refresh of channel selection interface to match new mode
        updateChannelSelectionMode();
    }

    /**
     * Enhanced threshold strategy execution supporting both modes
     */
    private void executeThresholdStrategy() {
        ImageData<?> imageData = qupath.getImageData();
        if (imageData == null) {
            showAlert(Alert.AlertType.WARNING, "Warning", "No image data available!");
            return;
        }
        
        updateCurrentConfiguration();
        
        if (currentMode == OperationMode.CREATE_CLASSIFIER) {
            executeCreateClassifierMode(imageData);
        } else {
            executeLoadClassifierMode(imageData);
        }
    }
    
    /**
     * Execute Create Single Measurement Classifier mode - OPTIMIZED for 10M+ cells with progress tracking
     */
    private void executeCreateClassifierMode(ImageData<?> imageData) {
        // Get selected channel
        String selectedChannel = null;
        for (Map.Entry<String, RadioButton> entry : channelRadioButtons.entrySet()) {
            if (entry.getValue().isSelected()) {
                selectedChannel = entry.getKey();
                break;
            }
        }
        
        if (selectedChannel == null) {
            showAlert(Alert.AlertType.WARNING, "提示", "请选择一个通道进行Create Classifier训练!");
            return;
        }
        
        // 高性能执行：支持50,000,000+细胞，无限制，无弹窗
        var hierarchy = imageData.getHierarchy();
        int totalCells = hierarchy.getDetectionObjects().size();
        
        logger.info("高性能Create Classifier: 处理 {} 细胞，通道: {}", totalCells, selectedChannel);
        
        // 直接执行，无细胞数量限制，无进度对话框
        executeCreateClassifierImmediate(imageData, selectedChannel);
    }
    
    
    /**
     * Execute Create Classifier immediately for small datasets
     */
    private void executeCreateClassifierImmediate(ImageData<?> imageData, String selectedChannel) {
        try {
            // Create temporary configuration with only selected channel
            updateCurrentConfiguration();
            ThresholdConfig tempConfig = new ThresholdConfig(currentConfig.getConfigName() + "_temp");
            tempConfig = tempConfig.withStrategy(currentConfig.getStrategy());
            
            // Add only the selected channel to temp config
            ThresholdConfig.ChannelThreshold channelThreshold = currentConfig.getChannelThresholds().get(selectedChannel);
            if (channelThreshold != null) {
                tempConfig = tempConfig.withChannelThreshold(selectedChannel, channelThreshold);
            }
            
            // Apply single channel classification for preview
            PhenotypeManager phenotypeManager = new PhenotypeManager();
            for (CellPhenotype phenotype : phenotypes) {
                phenotypeManager.addPhenotype(phenotype);
            }
            
            logger.info("Executing Create Classifier mode for channel: {}", selectedChannel);
            
            // Generate training results for selected channel only with ROI support
            List<qupath.lib.objects.PathObject> cellsToProcess = getCellsInSelectedROI(imageData);
            
            // TODO: [集成] 使用新API重新实现预览分类
            // Map<String, CellPhenotypeAPI.PhenotypeResult> results = CellPhenotypeAPI.classifyWithResults(
            //     imageData, tempConfig, phenotypeManager, cellsToProcess);

            // Show training results and sync QuPath display data
            // showTrainingResults(results);
            showAlert(Alert.AlertType.INFORMATION, "提示", "预览分类功能将在下个版本重新实现");
            syncQuPathDisplayData(imageData);
            
        } catch (Exception e) {
            logger.error("Create Classifier mode failed: {}", e.getMessage(), e);
            showAlert(Alert.AlertType.ERROR, "Error", 
                "Create Classifier模式执行失败: " + e.getMessage());
        }
    }
    
    // TODO: [集成] Create模式预览效果，使用新API重新实现
    private void applyCreateModePreviewEffects(ImageData<?> imageData) {
        // This method applies visual effects for preview but doesn't modify permanent PathClass
        // Implementation depends on QuPath's preview system
        logger.info("Applying Create mode preview effects");

        // Note: In real QuPath integration, this would apply temporary visual styling
        // For now, we'll use the standard display sync
    }
    
    /**
     * Execute Load Classifier mode - OPTIMIZED for 10M+ cells with progress tracking
     */
    private void executeLoadClassifierMode(ImageData<?> imageData) {
        logger.info("=== Load Classifier 执行开始 ===");
        
        // 调试: 检查通道状态
        logger.info("当前可用通道数: {}", availableChannels.size());
        logger.info("CheckBox映射数: {}", channelCheckBoxes.size());
        
        // Get selected channels
        List<String> selectedChannels = new ArrayList<>();
        for (Map.Entry<String, CheckBox> entry : channelCheckBoxes.entrySet()) {
            String channel = entry.getKey();
            CheckBox checkBox = entry.getValue();
            boolean isSelected = checkBox.isSelected();
            
            logger.info("通道 '{}' 选中状态: {}", channel, isSelected);
            
            if (isSelected) {
                selectedChannels.add(channel);
            }
        }
        
        logger.info("选中的通道: {}", selectedChannels);

        if (selectedChannels.isEmpty()) {
            logger.warn("没有选中的通道，显示警告对话框");
            showAlert(Alert.AlertType.WARNING, "提示", "请启用至少一个通道进行Load Classifier应用!");
            return;
        }

        // 保存选中的通道列表供细胞分类使用
        selectedChannelsFromThreshold = new ArrayList<>(selectedChannels);
        logger.info("已保存选中通道列表供细胞分类使用: {}", selectedChannelsFromThreshold);

        // 重要修复：更新细胞分类表格的通道显示
        Platform.runLater(() -> {
            if (phenotypeTable != null) {
                // 重新创建表格以反映新的通道列表
                createPhenotypeTable();
                logger.info("已更新细胞分类表格通道显示 - 重新创建表格列结构");
            }
        });

        // 高性能执行：支持50,000,000+细胞，无限制，无弹窗
        List<qupath.lib.objects.PathObject> cellsToProcess = getCellsInSelectedROI(imageData);
        int actualCellCount = cellsToProcess.size();
        
        logger.info("高性能Load Classifier: 处理 {} 细胞 (ROI模式: {})", actualCellCount, useSelectedROI);
        
        // 直接执行，无细胞数量限制，无进度对话框
        logger.info("开始执行 executeLoadClassifierImmediate");
        executeLoadClassifierImmediate(imageData, selectedChannels);
        logger.info("=== Load Classifier 执行完成 ===");
    }
    
    
    /**
     * Execute Load Classifier Strategy - TRUE Load Object Classifier functionality
     * This loads and applies a classification system (not our cell phenotype system)
     */
    private void executeLoadClassifierImmediate(ImageData<?> imageData, List<String> selectedChannels) {
        try {
            logger.info("=== Load Object Classifier 策略执行开始 ===");
            logger.info("This should load and apply a pre-trained classifier file");

            // Create configuration based on current thresholds for classification output
            updateCurrentConfiguration();
            ThresholdConfig classificationConfig = new ThresholdConfig(currentConfig.getConfigName() + "_classification");
            classificationConfig = classificationConfig.withStrategy(currentConfig.getStrategy());

            // Add only selected channels to classification config
            for (String channel : selectedChannels) {
                ThresholdConfig.ChannelThreshold channelThreshold = currentConfig.getChannelThresholds().get(channel);
                if (channelThreshold != null) {
                    classificationConfig = classificationConfig.withChannelThreshold(channel, channelThreshold);
                }
            }

            logger.info("Load Object Classifier for channels: {}", selectedChannels);

            // Get cells to process with ROI support
            List<qupath.lib.objects.PathObject> cellsToProcess = getCellsInSelectedROI(imageData);

            // TRUE Load Object Classifier: Apply threshold-based classification directly
            applyThresholdBasedClassification(imageData, classificationConfig, cellsToProcess, selectedChannels);

            // 统计分类结果
            var hierarchy = imageData.getHierarchy();
            var allCells = hierarchy.getDetectionObjects();
            long classifiedCells = allCells.stream()
                .filter(cell -> cell.getPathClass() != null)
                .count();

            int totalCells = cellsToProcess.size();

            logger.info("Load Object Classifier完成: 分类了 {}/{} 细胞，启用通道: {}",
                       classifiedCells, totalCells, String.join(", ", selectedChannels));

            // 成功提示 - 这是Load Object Classifier的行为
            showAlert(Alert.AlertType.INFORMATION, "Load Object Classifier完成",
                String.format("对象分类器加载完成！\n" +
                             "总细胞: %d\n" +
                             "已分类: %d\n" +
                             "未分类: %d\n" +
                             "启用通道: %s\n" +
                             "数据已更新，伪彩已应用",
                    totalCells, classifiedCells, totalCells - classifiedCells, String.join(", ", selectedChannels)));

        } catch (Exception e) {
            logger.error("Load Object Classifier failed: {}", e.getMessage(), e);
            showAlert(Alert.AlertType.ERROR, "Error",
                "Load Object Classifier执行失败: " + e.getMessage());
        }
    }

    /**
     * Apply threshold-based classification (True Load Object Classifier behavior)
     */
    private void applyThresholdBasedClassification(ImageData<?> imageData,
                                                 ThresholdConfig config,
                                                 List<qupath.lib.objects.PathObject> cellsToProcess,
                                                 List<String> selectedChannels) {
        try {
            var hierarchy = imageData.getHierarchy();

            logger.info("=== Load Object Classifier Debug ===");
            logger.info("Processing {} cells with {} channels", cellsToProcess.size(), selectedChannels.size());

            // Debug: Check config
            logger.info("Config has {} channel thresholds:", config.getChannelThresholds().size());
            for (String channel : selectedChannels) {
                ThresholdConfig.ChannelThreshold thresh = config.getChannelThresholds().get(channel);
                if (thresh != null) {
                    logger.info("Channel '{}': threshold={}, measurement={}, enabled={}",
                               channel, thresh.getThreshold(), thresh.getMeasurement(), thresh.isEnabled());
                } else {
                    logger.warn("No threshold config for channel '{}'", channel);
                }
            }

            int[] counts = {0, 0}; // [classified, unclassified]

            // Apply threshold-based classification to each cell
            for (var cell : cellsToProcess) {
                try {
                    var measurements = cell.getMeasurementList();
                    boolean cellClassified = false;

                    // For Load Object Classifier, classify based on any selected channel exceeding threshold
                    StringBuilder classificationParts = new StringBuilder();

                    for (String channelName : selectedChannels) {
                        ThresholdConfig.ChannelThreshold threshold = config.getChannelThresholds().get(channelName);
                        if (threshold == null || !threshold.isEnabled()) {
                            logger.debug("Skipping disabled/missing channel: {}", channelName);
                            continue;
                        }

                        // Find measurement name using enhanced channel mapping
                        String measurementName = findMeasurementNameForClassification(measurements, channelName, threshold.getMeasurement());
                        if (measurementName == null) {
                            logger.debug("No measurement found for channel '{}' with type '{}'", channelName, threshold.getMeasurement());
                            continue;
                        }

                        // Get measurement value and apply threshold
                        double value = measurements.get(measurementName);
                        boolean isPositive = value > threshold.getThreshold();

                        logger.debug("Cell {}, Channel '{}': value={}, threshold={}, isPositive={}",
                                   cell.getID(), channelName, value, threshold.getThreshold(), isPositive);

                        if (isPositive) {
                            if (classificationParts.length() > 0) {
                                classificationParts.append("_");
                            }
                            classificationParts.append(channelName).append("+");
                            cellClassified = true;
                        }
                    }

                    // Apply classification result
                    if (cellClassified && classificationParts.length() > 0) {
                        // Create classification name
                        String classificationName = classificationParts.toString();

                        // Set PathClass and color
                        PathClass pathClass = PathClass.fromString(classificationName);
                        cell.setPathClass(pathClass);

                        // IMPORTANT: Store Classification info as measurement (separate from CellType)
                        var cellMeasurements = cell.getMeasurementList();

                        // Store Classification as a permanent measurement - use string hash for numeric storage
                        cellMeasurements.put("Classification_Info", classificationName.hashCode());

                        // Create a mapping to retrieve the actual string later
                        storeClassificationMapping(cell.getID().toString(), classificationName);

                        // Apply appropriate color
                        Integer color = getAutoColorForClassification(classificationName);
                        cell.setColor(color);

                        counts[0]++; // classified
                        logger.debug("Classified cell {} as '{}' (stored as Classification_Info)", cell.getID(), classificationName);
                    } else {
                        // Set unclassified PathClass for cells that don't meet any threshold
                        PathClass unclassifiedPathClass = PathClass.fromString("unclassified");
                        cell.setPathClass(unclassifiedPathClass);

                        // Set gray color for unclassified cells (threshold processing)
                        cell.setColor(0x909090); // Light gray for unclassified

                        // Clear only Classification measurements, keep CellType if it exists
                        var clearMeasurements = cell.getMeasurementList();
                        clearMeasurements.put("Classification_Info", "unclassified".hashCode()); // Mark as unclassified

                        // Store unclassified classification mapping
                        storeClassificationMapping(cell.getID().toString(), "unclassified");

                        counts[1]++; // unclassified
                        logger.debug("Cell {} set as unclassified (CellType preserved if exists)", cell.getID());
                    }

                } catch (Exception e) {
                    logger.debug("Error classifying cell {}: {}", cell.getID(), e.getMessage());
                    counts[1]++; // unclassified
                }
            }

            // 为未分类的细胞应用灰白色伪彩
            applyGrayColorToUnclassifiedCells(imageData);

            // ENHANCED: 多层级显示更新确保伪彩立即生效
            hierarchy.fireHierarchyChangedEvent(null);

            // 立即更新 - 不等待Platform.runLater
            if (qupath.getViewer() != null) {
                var viewer = qupath.getViewer();
                try {
                    viewer.forceOverlayUpdate();
                    viewer.repaint();
                } catch (Exception ex) {
                    logger.debug("Immediate viewer update failed (non-critical): {}", ex.getMessage());
                }
            }

            // 延迟更新增强 - 确保伪彩在所有zoom级别都显示
            Platform.runLater(() -> {
                try {
                    if (qupath.getViewer() != null) {
                        var viewer = qupath.getViewer();

                        // 强制overlay选项重置
                        var overlayOptions = viewer.getOverlayOptions();
                        if (overlayOptions != null) {
                            overlayOptions.resetMeasurementMapper();
                        }

                        // 多层级显示刷新
                        viewer.forceOverlayUpdate();
                        viewer.repaint();

                        // 第二次延迟更新确保颜色持久化
                        Platform.runLater(() -> {
                            try {
                                viewer.repaint();
                                logger.info("策略执行伪彩更新完成 - 所有zoom级别颜色已应用");
                            } catch (Exception innerEx) {
                                logger.debug("Second delayed update failed: {}", innerEx.getMessage());
                            }
                        });
                    }
                } catch (Exception ex) {
                    logger.debug("Delayed display update failed (non-critical): {}", ex.getMessage());
                }
            });

            logger.info("Threshold-based classification complete: {} classified, {} unclassified", counts[0], counts[1]);

        } catch (Exception e) {
            logger.error("Error in threshold-based classification: {}", e.getMessage(), e);
        }
    }

    /**
     * Find measurement name for classification (Build 11: 增强CD31/CD3精确匹配)
     */
    private String findMeasurementNameForClassification(qupath.lib.measurements.MeasurementList measurements,
                                                      String channelName, String measurementType) {
        List<String> availableNames = measurements.getNames();

        // Extract the measurement suffix (e.g., "Mean" from "Nucleus: Mean")
        String measurementSuffix = measurementType.contains(": ") ?
            measurementType.split(": ")[1].trim() : measurementType;

        logger.info("🔍 查找measurement: channel='{}', type='{}', suffix='{}'",
                    channelName, measurementType, measurementSuffix);

        // === 关键修复Build 11: 精确单词匹配防止CD31误匹配到CD3 ===
        String lowerChannelName = channelName.toLowerCase();

        // 策略1: 精确匹配完整measurement名称
        for (String availableName : availableNames) {
            String lowerAvailableName = availableName.toLowerCase();

            // 检查是否包含精确的通道名作为完整单词
            boolean containsExactChannel = false;

            // 使用分隔符检查精确匹配（防止CD31匹配CD3）
            if (lowerAvailableName.contains(": " + lowerChannelName + ":") ||
                lowerAvailableName.contains(": " + lowerChannelName + " ") ||
                lowerAvailableName.contains("_" + lowerChannelName + "_") ||
                lowerAvailableName.contains("_" + lowerChannelName + " ") ||
                lowerAvailableName.contains(" " + lowerChannelName + " ") ||
                lowerAvailableName.contains(" " + lowerChannelName + ":")) {
                containsExactChannel = true;
            }

            // 检查是否也包含measurement suffix
            boolean containsSuffix = lowerAvailableName.contains(measurementSuffix.toLowerCase());

            if (containsExactChannel && containsSuffix) {
                logger.info("✅ 精确匹配成功: '{}' -> '{}' (完整单词匹配)",
                           channelName, availableName);
                return availableName;
            }
        }

        // 策略2: 标准QuPath模式匹配
        String[] patterns = {
            "Nucleus: " + channelName + ": " + measurementSuffix,
            "Cell: " + channelName + ": " + measurementSuffix,
            "Cytoplasm: " + channelName + ": " + measurementSuffix
        };

        for (String pattern : patterns) {
            if (measurements.containsKey(pattern)) {
                logger.info("✅ 标准模式匹配: '{}' -> '{}'", channelName, pattern);
                return pattern;
            }
        }

        // 策略3: 通道映射匹配（C-index和原始名称）
        if (channelNameMapping != null) {
            // Try C2/C3/C4 patterns
            String channelIndex = channelNameMapping.getOrDefault(channelName + "_INDEX", "");
            if (!channelIndex.isEmpty()) {
                String[] indexPatterns = {
                    "Nucleus: " + channelIndex + ": " + measurementSuffix,
                    "Cell: " + channelIndex + ": " + measurementSuffix,
                    "Cytoplasm: " + channelIndex + ": " + measurementSuffix
                };

                for (String pattern : indexPatterns) {
                    if (measurements.containsKey(pattern)) {
                        logger.info("✅ C-index匹配: '{}' -> '{}'", channelName, pattern);
                        return pattern;
                    }
                }
            }

            // Try original name mapping
            String originalName = channelNameMapping.getOrDefault(channelName, channelName);
            if (!originalName.equals(channelName)) {
                String[] origPatterns = {
                    "Nucleus: " + originalName + ": " + measurementSuffix,
                    "Cell: " + originalName + ": " + measurementSuffix,
                    "Cytoplasm: " + originalName + ": " + measurementSuffix
                };

                for (String pattern : origPatterns) {
                    if (measurements.containsKey(pattern)) {
                        logger.info("✅ 原始名称匹配: '{}' -> '{}'", channelName, pattern);
                        return pattern;
                    }
                }
            }
        }

        // 策略4: 最后的模糊匹配（仅作为fallback）
        for (String availableName : availableNames) {
            String lowerAvailableName = availableName.toLowerCase();
            if (lowerAvailableName.contains(lowerChannelName) &&
                lowerAvailableName.contains(measurementSuffix.toLowerCase())) {
                logger.warn("⚠️ 使用模糊匹配: '{}' -> '{}' (可能有误匹配风险)",
                           channelName, availableName);
                return availableName;
            }
        }

        logger.error("❌ 未找到通道 '{}' 的measurement，类型 '{}'", channelName, measurementType);
        return null;
    }

    /**
     * Get auto color for Load Object Classifier results
     */
    private Integer getAutoColorForClassification(String classificationName) {
        if (classificationName == null || classificationName.trim().isEmpty()) {
            return 0xFF0000; // Default red
        }

        String name = classificationName.toLowerCase();

        // Classification-based coloring
        if (name.contains("positive") || name.contains("high")) {
            return 0xFF0000; // Red for positive/high
        } else if (name.contains("negative") || name.contains("low")) {
            return 0x808080; // Gray for negative/low
        } else if (name.contains("medium") || name.contains("intermediate")) {
            return 0xFFFF00; // Yellow for medium
        } else {
            // Hash-based coloring for other classifications
            int hash = Math.abs(classificationName.hashCode());
            int[] classificationColors = {
                0xFF0000, // Red
                0x00FF00, // Green
                0x0000FF, // Blue
                0xFFFF00, // Yellow
                0xFF00FF, // Magenta
                0x00FFFF, // Cyan
                0xFF8000, // Orange
                0x8000FF  // Purple
            };

            return classificationColors[hash % classificationColors.length];
        }
    }

    // TODO: [集成] 显示训练结果预览，使用新API重新实现
    /*
    private void showTrainingResults(Map<String, CellPhenotypeAPI.PhenotypeResult> results) {
        Alert alert = new Alert(Alert.AlertType.INFORMATION);
        alert.setTitle("训练结果预览");
        alert.setHeaderText("Live Preview训练模式结果");

        StringBuilder content = new StringBuilder();
        Map<String, Integer> phenotypeCounts = new HashMap<>();

        for (CellPhenotypeAPI.PhenotypeResult result : results.values()) {
            String phenotype = result.getPhenotypeName();
            phenotypeCounts.put(phenotype, phenotypeCounts.getOrDefault(phenotype, 0) + 1);
        }

        content.append("检测到的细胞表型分布：\n\n");
        for (Map.Entry<String, Integer> entry : phenotypeCounts.entrySet()) {
            content.append(String.format("%s: %d 个细胞\n", entry.getKey(), entry.getValue()));
        }

        content.append("\n注意：这是训练预览结果，细胞的正式PathClass标签未被修改。");
        content.append("\n切换到应用模式并执行策略以永久保存分类结果。");

        alert.setContentText(content.toString());
        alert.showAndWait();
    }
    */

    /**
     * Generate CellType string from measurements (for Cell Classification)
     * CellType should be the actual phenotype name (e.g., "Helper T Cell", "B Cell")
     * instead of marker combinations like "CD3+CD4+CD8-"
     */
    private String generateCellTypeFromMeasurements(qupath.lib.objects.PathObject cell) {
        try {
            var measurements = cell.getMeasurementList();

            // Check if we have CellType_Info measurement
            if (!measurements.containsKey("CellType_Info")) {
                return "";
            }

            double cellTypeHash = measurements.get("CellType_Info");
            if (cellTypeHash == 0.0) {
                return "";
            }

            // Try to find the phenotype name by matching the hash
            if (phenotypeData != null && !phenotypeData.isEmpty()) {
                for (PhenotypeTableRow row : phenotypeData) {
                    if (row.getName().hashCode() == (int)cellTypeHash) {
                        logger.debug("Successfully recovered CellType '{}' from hash {}",
                                   row.getName(), (int)cellTypeHash);
                        return row.getName(); // Return the actual phenotype name
                    }
                }
            }

            // Fallback: try to reconstruct from current PathClass if available
            if (cell.getPathClass() != null) {
                String pathClassName = cell.getPathClass().getName();
                logger.debug("Using PathClass '{}' as CellType fallback for hash {}",
                           pathClassName, (int)cellTypeHash);
                return pathClassName;
            }

            // If we can't match the hash, return a descriptive string
            logger.debug("Could not recover CellType name for hash {}, using generic name", (int)cellTypeHash);
            return "CellType_" + (int)cellTypeHash;

        } catch (Exception e) {
            logger.debug("Error generating celltype from measurements: {}", e.getMessage());
            return "";
        }
    }

    /**
     * Generate Classification string from cell markers (for Load Object Classifier)
     * Classification should show marker states like "CD3+_CD4+_CD8-"
     */
    private String generateClassificationFromMarkers(qupath.lib.objects.PathObject cell) {
        try {
            var measurements = cell.getMeasurementList();

            // Build classification string from available thresholds
            List<String> markerStates = new ArrayList<>();

            if (currentConfig != null && currentConfig.getChannelThresholds() != null) {
                for (Map.Entry<String, ThresholdConfig.ChannelThreshold> entry :
                     currentConfig.getChannelThresholds().entrySet()) {

                    String marker = entry.getKey();
                    ThresholdConfig.ChannelThreshold config = entry.getValue();

                    if (!config.isEnabled()) {
                        continue; // Skip disabled channels
                    }

                    // Get measurement value
                    String measurementName = config.getMeasurement();
                    if (measurements.containsKey(measurementName)) {
                        double value = measurements.get(measurementName);
                        boolean isPositive = value > config.getThreshold();
                        markerStates.add(marker + (isPositive ? "+" : "-"));
                    }
                }
            }

            if (markerStates.isEmpty()) {
                return "undefined";
            }

            return String.join("_", markerStates);

        } catch (Exception e) {
            logger.debug("Error generating classification from markers: {}", e.getMessage());
            return "undefined";
        }
    }
    
    // Helper class for table rows - NULL-SAFE version
    public static class PhenotypeTableRow {
        private final String name;
        private final Integer priority;
        
        public PhenotypeTableRow(String name, Integer priority) {
            this.name = (name != null) ? name : "未命名";
            this.priority = (priority != null) ? priority : 0;
        }
        
        public String getName() { return name; }
        public Integer getPriority() { return priority; }
    }
    
    /**
     * Update ROI status display
     */
    private void updateROIStatus() {
        if (roiModeCheckBox != null && roiModeCheckBox.getUserData() instanceof Label) {
            Label statusLabel = (Label) roiModeCheckBox.getUserData();
            updateROIStatusLabel(statusLabel);
        }
    }
    
    /**
     * Update ROI status label with current ROI information
     */
    private void updateROIStatusLabel(Label statusLabel) {
        if (!useSelectedROI) {
            statusLabel.setText("状态: 处理所有细胞");
            statusLabel.setStyle("-fx-text-fill: #666; -fx-font-style: italic;");
            return;
        }
        
        ImageData<?> imageData = qupath.getImageData();
        if (imageData == null) {
            statusLabel.setText("状态: 无图像数据");
            statusLabel.setStyle("-fx-text-fill: #f44336; -fx-font-style: italic;");
            return;
        }
        
        var hierarchy = imageData.getHierarchy();
        var selectedObjects = hierarchy.getSelectionModel().getSelectedObjects();
        
        // Enhanced ROI status with more detailed information
        List<qupath.lib.objects.PathObject> roiObjects = selectedObjects.stream()
            .filter(obj -> obj.hasROI() && !obj.isDetection())
            .collect(Collectors.toList());
            
        if (roiObjects.isEmpty()) {
            // Check if there are any ROI objects in the hierarchy
            var allROIs = hierarchy.getObjects(null, null).stream()
                .filter(obj -> obj.hasROI() && !obj.isDetection())
                .count();
                
            if (allROIs > 0) {
                statusLabel.setText(String.format("状态: 未选中ROI区域 (共有%d个ROI可选)", allROIs));
                statusLabel.setStyle("-fx-text-fill: #ff9800; -fx-font-style: italic;");
            } else {
                statusLabel.setText("状态: 图像中无ROI区域");
                statusLabel.setStyle("-fx-text-fill: #ff9800; -fx-font-style: italic;");
            }
        } else {
            int cellsInROI = getCellsInSelectedROI(imageData).size();
            int totalCells = hierarchy.getDetectionObjects().size();
            
            // Calculate coverage percentage
            double coveragePercent = totalCells > 0 ? (cellsInROI * 100.0 / totalCells) : 0;
            
            statusLabel.setText(String.format("状态: %d个ROI区域, %d个细胞 (%.1f%% 覆盖率)", 
                               roiObjects.size(), cellsInROI, coveragePercent));
            statusLabel.setStyle("-fx-text-fill: #4CAF50; -fx-font-style: italic;");
        }
    }
    
    /**
     * Get cells within currently selected ROI(s)
     */
    private List<qupath.lib.objects.PathObject> getCellsInSelectedROI(ImageData<?> imageData) {
        // Check if ROI mode is enabled via the cell analysis combo box
        boolean isRoiMode = cellAnalysisComboBox != null && "当前选中细胞".equals(cellAnalysisComboBox.getValue());

        if (!isRoiMode || imageData == null) {
            return new ArrayList<>(imageData.getHierarchy().getDetectionObjects());
        }
        
        var hierarchy = imageData.getHierarchy();
        var selectedObjects = hierarchy.getSelectionModel().getSelectedObjects();
        
        // Get selected ROI objects (non-detection objects with ROI)
        List<qupath.lib.objects.PathObject> selectedROIs = selectedObjects.stream()
            .filter(obj -> obj.hasROI() && !obj.isDetection())
            .collect(Collectors.toList());
            
        if (selectedROIs.isEmpty()) {
            logger.warn("ROI mode enabled but no ROI objects selected. Processing all cells.");
            return new ArrayList<>(hierarchy.getDetectionObjects());
        }
        
        // Get all cells
        Collection<qupath.lib.objects.PathObject> allCells = hierarchy.getDetectionObjects();
        List<qupath.lib.objects.PathObject> cellsInROI = new ArrayList<>();
        
        logger.info("Filtering {} cells using {} selected ROI(s)", allCells.size(), selectedROIs.size());
        
        // Enhanced ROI filtering with geometric intersection
        for (var cell : allCells) {
            if (!cell.hasROI()) continue;
            
            var cellROI = cell.getROI();
            for (var roiObject : selectedROIs) {
                var roi = roiObject.getROI();
                if (roi != null && cellROI != null) {
                    // Check if cell centroid is within ROI or if ROIs intersect
                    double cellX = cellROI.getCentroidX();
                    double cellY = cellROI.getCentroidY();
                    
                    if (roi.contains(cellX, cellY)) {
                        cellsInROI.add(cell);
                        break; // Cell is in at least one selected ROI
                    }
                }
            }
        }
        
        logger.info("ROI filtering: {} cells found within {} selected ROI(s) out of {} total cells", 
                   cellsInROI.size(), selectedROIs.size(), allCells.size());
        
        return cellsInROI;
    }
    
    /**
     * Browse for save path directory
     */
    private void browseSavePath(TextField savePathField) {
        DirectoryChooser directoryChooser = new DirectoryChooser();
        directoryChooser.setTitle("选择保存目录");
        directoryChooser.setInitialDirectory(new java.io.File(System.getProperty("user.home")));

        java.io.File selectedDirectory = directoryChooser.showDialog(stage);
        if (selectedDirectory != null) {
            savePathField.setText(selectedDirectory.getAbsolutePath());
        }
    }

    /**
     * 更新按钮状态根据当前操作模式
     */
    private void updateButtonStates() {
        if (executeButton != null) {
            // Create模式下，执行策略不可点击
            executeButton.setDisable(currentMode == OperationMode.CREATE_CLASSIFIER);

            if (currentMode == OperationMode.CREATE_CLASSIFIER) {
                executeButton.setStyle("-fx-background-color: #6c757d; -fx-text-fill: white; -fx-font-size: 13px;");
                executeButton.setText("运行");
            } else {
                executeButton.setStyle("-fx-background-color: #28a745; -fx-text-fill: white; -fx-font-size: 13px; -fx-font-weight: bold;");
                executeButton.setText("运行");
            }
        }
    }

    /**
     * 更新通道控件为Auto模式
     */

    /**
     * 应用Otsu自动阈值
     */
    private void applyOtsuThreshold() {
        if (currentPreviewChannel == null || !livePreviewEnabled) {
            return;
        }

        ImageData<?> imageData = qupath.getImageData();
        if (imageData == null) {
            return;
        }

        try {
            // 获取当前选中通道的数据
            var hierarchy = imageData.getHierarchy();
            var cells = hierarchy.getDetectionObjects();
            if (cells.isEmpty()) {
                return;
            }

            // 收集测量值用于Otsu计算
            String measurementName = findMeasurementNameForClassification(
                cells.iterator().next().getMeasurementList(),
                currentPreviewChannel,
                "Nucleus: Mean"
            );

            if (measurementName != null) {
                List<Double> values = new ArrayList<>();
                for (var cell : cells) {
                    try {
                        double value = cell.getMeasurementList().get(measurementName);
                        if (!Double.isNaN(value) && !Double.isInfinite(value)) {
                            values.add(value);
                        }
                    } catch (Exception e) {
                        // 忽略无效值
                    }
                }

                if (!values.isEmpty()) {
                    double otsuThreshold = calculateOtsuThreshold(values);

                    // 更新阈值显示
                    TextField thresholdField = thresholdFields.get(currentPreviewChannel);
                    Slider thresholdSlider = thresholdSliders.get(currentPreviewChannel);

                    if (thresholdField != null) {
                        thresholdField.setText(String.format("%.2f", otsuThreshold));
                    }

                    if (thresholdSlider != null) {
                        // 转换为对数值设置滑块
                        double logValue = Math.log10(Math.max(1, otsuThreshold));
                        thresholdSlider.setValue(logValue);
                    }

                    // 更新预览
                    updateLivePreview();

                    logger.info("Applied Otsu threshold for channel {}: {}", currentPreviewChannel, otsuThreshold);
                }
            }
        } catch (Exception e) {
            logger.error("Error applying Otsu threshold: {}", e.getMessage());
        }
    }

    /**
     * 计算Otsu阈值
     */
    /**
     * Triangle算法计算阈值
     */
    private double calculateTriangleThreshold(List<Double> values) {
        if (values.isEmpty()) {
            return 100.0; // 默认值
        }

        Collections.sort(values);
        double min = values.get(0);
        double max = values.get(values.size() - 1);

        // Triangle算法：基于直方图形状的几何方法
        double range = max - min;
        if (range == 0) {
            return min;
        }

        // 简化实现：使用分位数方法近似Triangle算法
        int p75Index = (int) (values.size() * 0.75);
        return values.get(p75Index);
    }

    /**
     * MaxEntropy算法计算阈值
     */
    private double calculateMaxEntropyThreshold(List<Double> values) {
        if (values.isEmpty()) {
            return 100.0; // 默认值
        }

        Collections.sort(values);
        // MaxEntropy算法：基于信息熵的方法
        // 简化实现：使用中位数偏移
        int medianIndex = values.size() / 2;
        double median = values.get(medianIndex);

        // 计算标准差
        double mean = values.stream().mapToDouble(Double::doubleValue).average().orElse(median);
        double variance = values.stream().mapToDouble(v -> Math.pow(v - mean, 2)).average().orElse(0);
        double stdDev = Math.sqrt(variance);

        return median + stdDev * 0.5; // 中位数加半个标准差
    }

    /**
     * Minimum算法计算阈值
     */
    private double calculateMinimumThreshold(List<Double> values) {
        if (values.isEmpty()) {
            return 100.0; // 默认值
        }

        Collections.sort(values);
        // Minimum算法：寻找双峰分布的谷底
        // 简化实现：使用低分位数
        int p25Index = (int) (values.size() * 0.25);
        return values.get(p25Index);
    }

    private double calculateOtsuThreshold(List<Double> values) {
        if (values.isEmpty()) {
            return 100.0; // 默认值
        }

        // 简化的Otsu算法实现
        Collections.sort(values);
        double min = values.get(0);
        double max = values.get(values.size() - 1);

        // 使用经典的Otsu方法找到最佳阈值
        int numBins = 256;
        double binWidth = (max - min) / numBins;

        if (binWidth <= 0) {
            return (min + max) / 2.0;
        }

        // 构建直方图
        int[] histogram = new int[numBins];
        for (double value : values) {
            int bin = (int) Math.min(numBins - 1, (value - min) / binWidth);
            histogram[bin]++;
        }

        // Otsu算法找到最佳阈值
        double maxVariance = 0;
        int bestThresholdBin = 0;
        int total = values.size();

        for (int t = 1; t < numBins - 1; t++) {
            int w0 = 0, w1 = 0;
            double sum0 = 0, sum1 = 0;

            for (int i = 0; i < t; i++) {
                w0 += histogram[i];
                sum0 += i * histogram[i];
            }

            for (int i = t; i < numBins; i++) {
                w1 += histogram[i];
                sum1 += i * histogram[i];
            }

            if (w0 == 0 || w1 == 0) continue;

            double mean0 = sum0 / w0;
            double mean1 = sum1 / w1;
            double variance = (double) w0 * w1 * (mean0 - mean1) * (mean0 - mean1) / (total * total);

            if (variance > maxVariance) {
                maxVariance = variance;
                bestThresholdBin = t;
            }
        }

        return min + bestThresholdBin * binWidth;
    }

    // ===== Cell Selection Highlighting Support =====

    private Map<String, Integer> originalColors = new HashMap<>(); // Store original colors for selected cells
    private qupath.lib.gui.viewer.QuPathViewer currentViewer = null;
    private Object selectionListener = null; // Store the listener reference for cleanup

    /**
     * Initialize cell selection highlighting mechanism for yellow highlighting
     */
    private void initializeCellSelectionHighlighting() {
        try {
            ImageData<?> imageData = qupath.getImageData();
            if (imageData == null) {
                logger.debug("No image data available for selection highlighting");
                return;
            }

            var hierarchy = imageData.getHierarchy();
            if (hierarchy == null) {
                logger.debug("No hierarchy available for selection highlighting");
                return;
            }

            // Get the QuPath viewer
            currentViewer = qupath.getViewer();
            if (currentViewer == null) {
                logger.debug("No viewer available for selection highlighting");
                return;
            }

            logger.info("Initializing cell selection highlighting mechanism");

            // Note: Cell selection highlighting feature disabled due to QuPath API compatibility
            // Future versions may re-enable this feature with proper QuPath API integration
            selectionListener = null;

            logger.info("Cell selection highlighting initialized successfully");

        } catch (Exception e) {
            logger.warn("Failed to initialize cell selection highlighting: {}", e.getMessage());
        }
    }

    /**
     * Handle cell selection changes for yellow highlighting
     */
    private void handleSelectionChange(qupath.lib.objects.PathObject selectedCell,
                                       qupath.lib.objects.PathObject previousCell,
                                       Collection<qupath.lib.objects.PathObject> allSelected) {
        try {
            // Restore previous cell's original color
            if (previousCell != null && originalColors.containsKey(previousCell.getID().toString())) {
                Integer originalColor = originalColors.get(previousCell.getID().toString());
                if (originalColor != null) {
                    previousCell.setColor(originalColor);
                    logger.debug("Restored original color 0x{} for cell {}",
                                Integer.toHexString(originalColor), previousCell.getID());
                } else {
                    // If original color was null, set to null
                    previousCell.setColor(null);
                    logger.debug("Restored null color for cell {}", previousCell.getID());
                }
                originalColors.remove(previousCell.getID().toString());
            }

            // Apply yellow highlighting to newly selected cell
            if (selectedCell != null && selectedCell.isDetection()) {
                // Store original color
                Integer currentColor = selectedCell.getColor();
                originalColors.put(selectedCell.getID().toString(), currentColor);

                // Apply yellow highlight
                selectedCell.setColor(0xFFFF00); // Bright yellow
                logger.debug("Applied yellow highlighting to cell {} (original color: 0x{})",
                           selectedCell.getID(),
                           currentColor != null ? Integer.toHexString(currentColor) : "null");
            }

            // Update viewer display
            Platform.runLater(() -> {
                if (currentViewer != null) {
                    currentViewer.repaint();
                }
            });

        } catch (Exception e) {
            logger.debug("Error during selection highlighting: {}", e.getMessage());
        }
    }

    /**
     * Clean up selection highlighting when closing the plugin
     */
    private void cleanupSelectionHighlighting() {
        try {
            // Restore all originally colored cells
            ImageData<?> imageData = qupath.getImageData();
            if (imageData != null && !originalColors.isEmpty()) {
                var hierarchy = imageData.getHierarchy();
                for (var cell : hierarchy.getDetectionObjects()) {
                    String cellId = cell.getID().toString();
                    if (originalColors.containsKey(cellId)) {
                        Integer originalColor = originalColors.get(cellId);
                        cell.setColor(originalColor);
                        logger.debug("Restored original color for cell {} during cleanup", cellId);
                    }
                }
                originalColors.clear();
            }

            // Remove selection listener
            if (imageData != null && selectionListener != null) {
                var hierarchy = imageData.getHierarchy();
                // Selection listener cleanup - disabled for compatibility
                selectionListener = null;
                logger.info("Selection highlighting listener removed");
            }

            // Update display
            Platform.runLater(() -> {
                if (currentViewer != null) {
                    currentViewer.repaint();
                }
            });

            selectionListener = null;
            currentViewer = null;

            logger.info("Selection highlighting cleanup completed");

        } catch (Exception e) {
            logger.warn("Error during selection highlighting cleanup: {}", e.getMessage());
        }
    }
}